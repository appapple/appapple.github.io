<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Linux学习 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="—–title: TsetMindNOdedata: 2020-07-11 17:51:46tags:——- Linux学习《Linux就该这么学》刘遄https:&#x2F;&#x2F;www.linuxprobe.com&#x2F;chapter-00.html 第二章 新手必须掌握的Linux命令本章首先介绍系统内核和Shell终端的关系与作用，然后介绍Bash解释器的4大优势并学习Linux命令的执行方法。经验丰富的运">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux学习">
<meta property="og:url" content="http://yoursite.com/2020/07/10/Linux%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="—–title: TsetMindNOdedata: 2020-07-11 17:51:46tags:——- Linux学习《Linux就该这么学》刘遄https:&#x2F;&#x2F;www.linuxprobe.com&#x2F;chapter-00.html 第二章 新手必须掌握的Linux命令本章首先介绍系统内核和Shell终端的关系与作用，然后介绍Bash解释器的4大优势并学习Linux命令的执行方法。经验丰富的运">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-07-10T04:16:56.000Z">
<meta property="article:modified_time" content="2020-07-11T10:18:27.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Linux学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/10/Linux%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2020-07-10T04:16:56.000Z" itemprop="datePublished">2020-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Linux学习
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>—–<br>title: TsetMindNOde<br>data: 2020-07-11 17:51:46<br>tags:<br>——-</p>
<h1 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h1><h2 id="《Linux就该这么学》刘遄"><a href="#《Linux就该这么学》刘遄" class="headerlink" title="《Linux就该这么学》刘遄"></a>《Linux就该这么学》刘遄</h2><p><a href="https://www.linuxprobe.com/chapter-00.html" target="_blank" rel="noopener">https://www.linuxprobe.com/chapter-00.html</a></p>
<h3 id="第二章-新手必须掌握的Linux命令"><a href="#第二章-新手必须掌握的Linux命令" class="headerlink" title="第二章 新手必须掌握的Linux命令"></a>第二章 新手必须掌握的Linux命令</h3><p>本章首先介绍系统内核和<a href="https://www.linuxcool.com/" target="_blank" rel="noopener">Shell</a>终端的关系与作用，然后介绍Bash解释器的4大优势并学习Linux<a href="https://www.linuxcool.com/" target="_blank" rel="noopener">命令</a>的执行方法。经验丰富的运维人员可以通过合理地组合适当的<a href="https://www.linuxcool.com/" target="_blank" rel="noopener">命令</a>与参数，来更精准地满足工作需求，迅速得到自己想要的结果，还可以尽可能地降低系统资源消耗。</p>
<p>本书精挑细选出读者有必要首先学习的数十个Linux命令，它们与系统工作、系统状态、工作目录、文件、目录、打包压缩与搜索等主题相关。通过把上述命令归纳到本章中的各个小节，让您可以分门别类地逐个学习这些最基础的Linux命令，为今后学习更复杂的命令和服务做好必备知识铺垫。</p>
<pre><code>[2.1 强大好用的SHELL](https://www.linuxprobe.com/chapter-02.html#21_SHELL)
[2.2 执行查看帮助命令](https://www.linuxprobe.com/chapter-02.html#22)
[2.3 常用系统工作命令](https://www.linuxprobe.com/chapter-02.html#23)
[2.4 系统状态检测命令](https://www.linuxprobe.com/chapter-02.html#24)
[2.5 工作目录切换命令](https://www.linuxprobe.com/chapter-02.html#25)
[2.6 文本文件编辑命令](https://www.linuxprobe.com/chapter-02.html#26)
[2.7 文件目录管理命令](https://www.linuxprobe.com/chapter-02.html#27)
[2.8 打包压缩与搜索命令](https://www.linuxprobe.com/chapter-02.html#28)</code></pre><ul>
<li><p>2.1 强大好用的SHELL</p>
<p>  Shell就是这样的一个命令行工具。<strong>Shell（也称为终端或壳）充当的是人与内核（硬件）之间的翻译官</strong>，用户把一些命令“告诉”终端，它就会调用相应的程序服务去完成某些工作。现在包括<a href="https://www.linuxprobe.com/" target="_blank" rel="noopener">红帽</a>系统在内的许多<strong>主流Linux系统默认使用的终端是Bash（Bourne-Again SHell）解释器</strong>。主流Linux系统选择Bash解释器作为命令行终端主要有以下4项优势，读者可以在今后的学习和生产工作中细细体会Linux系统命令行的美妙之处，真正从心里爱上它们。</p>
<p>  通常来讲，计算机硬件是由运算器、控制器、存储器、输入/输出设备等共同组成的，而让各种硬件设备各司其职且又能协同运行的东西就是系统内核。<a href="https://www.linuxprobe.com/" target="_blank" rel="noopener">Linux系统</a>的内核负责完成对硬件资源的分配、调度等管理任务。由此可见，系统内核对计算机的正常运行来讲是太重要了，因此一般不建议直接去编辑内核中的参数，而是让用户通过基于系统调用接口开发出的程序或服务来管理计算机，以满足日常工作的需要，如图2-1所示。<br>  必须肯定的是，Linux系统中有些图形化工具（比如逻辑卷管理器[Logical Volume Manager，LVM]）确实非常好用，极大地降低了运维人员操作出错的概率，值得称赞。但是，很多图形化工具其实是调用了<a href="https://www.linuxcool.com/" target="_blank" rel="noopener">脚本</a>来完成相应的工作，往往只是为了完成某种工作而设计的，缺乏Linux命令原有的灵活性及可控性。再者，图形化工具相较于Linux命令行界面会更加消耗系统资源，因此经验丰富的运维人员甚至都不会给Linux系统安装图形界面，需要开始运维工作时直接通过命令行模式远程连接过去，不得不说这样做确实挺高效的。</p>
<ul>
<li><p>1：通过上下方向键来调取过往执行过的Linux命令；</p>
</li>
<li><p>2：命令或参数仅需输入前几位就可以用Tab键补全；</p>
</li>
<li><p>3：具有强大的批处理脚本；</p>
</li>
<li><p>4：具有实用的环境变量功能。</p>
</li>
</ul>
</li>
<li><p>2.2 执行查看帮助命令</p>
<ul>
<li><p>常见的命令格式: 命令名称 [命令参数] [命令对象]</p>
<ul>
<li><p>命令参数 : 而命令参数可以用长格式（完整的选项名称），也可以用短格式（单个字母的缩写），两者分别用–与-作为前缀</p>
</li>
<li><p>命令对象 : 指要处理的文件、目录、用户等资源</p>
</li>
</ul>
</li>
<li><p>man命令帮助信息的结构与意义</p>
<ul>
<li>NAME : 命令的名称<br>SYNOPSIS : 参数的大致用法<br>DESCRIPTION : 介绍说明<br>EXAMPLES : 演示(附带简单说明)<br>OVERVIEW : 概述<br>DEFAULTS : 默认的功能<br>OPTIONS : 具体的可用事项(带介绍)<br>ENVIRONMENT : 环境变量<br>FILES : 用到的文件<br>SEE ALSO : 相关的资料<br>HISTORY : 维护历史与联系方式</li>
</ul>
</li>
<li><p>man中常用的按键与用途</p>
<ul>
<li><p>空格键 : 向下一翻页<br>PaGe down : 向下翻一页<br>PaGe up : 向上翻一页<br>home : 直接前往首页 end : 直接前往尾页 / : 从上至下搜索某个关键词 , 如 /linux<br>? : 从下至上搜索某个关键词 , 如 ?linux<br>n : 定位到下一个搜索到的关键词<br>N : 定位到上一个搜索到的关键词<br>q : 退出帮助文档</p>
<p>  按键<br>  用处<br>  空格键<br>  向下翻一页<br>  PaGe down<br>  向下翻一页<br>  PaGe up<br>  向上翻一页<br>  home<br>  直接前往首页<br>  end<br>  直接前往尾页<br>  /<br>  从上至下搜索某个关键词，如“/linux”<br>  ?<br>  从下至上搜索某个关键词，如“?linux”<br>  n<br>  定位到下一个搜索到的关键词<br>  N<br>  定位到上一个搜索到的关键词<br>  q<br>  退出帮助文档</p>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li><p>2.3 常用系统工作命令</p>
<ul>
<li><p>1.echo命令 : <strong>用于在终端输出字符串或变量提取后的值</strong></p>
<ul>
<li><p>格式为 : echo [字符串 | $变量]</p>
<ul>
<li><p>例子</p>
<p>  例如  </p>
<p>  把指定字符串“Linuxprobe.com”输出到终端屏幕的命令为：</p>
<p>  [root@linuxprobe ~]# echo<br>  <a href="http://Linuxprobe.Com" target="_blank" rel="noopener">Linuxprobe.Com</a></p>
<p>  该命令会在终端屏幕上显示如下信息：<br>  <a href="http://Linuxprobe.Com" target="_blank" rel="noopener">Linuxprobe.Com</a></p>
<p>  下面，我们使用$变量的方式提取变量SHELL的值，并将其输出到屏幕上：</p>
<p>  [root@linuxprobe ~]# echo $SHELL<br>  /bin/bash</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.date命令 : 用于显示及设置系统的时间或日期</p>
<ul>
<li><p>格式为: date [选项] [+指定的格式]</p>
<ul>
<li><p>date命令中的参数及作用</p>
<ul>
<li><p>参数</p>
<ul>
<li>-s : 设置当前系统时间</li>
</ul>
</li>
<li><p>只需在date命令中输入以[”+”]号开头的参数,即可按照指定的格式输出系统的时间或日期</p>
<p>  这样在日常工作时便可以把备份数据的命令与指定格式输出的时间信息结合到一起。例如，把打包后的文件自动按照“年-月-日”的格式打包成“backup-2017-9-1.tar.gz”，用户只需要看一眼文件名称就能大概了解到每个文件的备份时间了</p>
<ul>
<li>%t : 跳格[Tab键]<br>%H : 小时(00<del>23)<br>%I : 小时(00</del>12)<br>%M : 分钟(00<del>59)<br>%S : 秒(00</del>59)<br>%j : 今年中的第几天</li>
</ul>
</li>
<li><p>例子</p>
<p>  按照默认格式查看当前系统时间的date命令如下所示：<br>  [root@linuxprobe ~]# date<br>  Mon Aug 24 16:11:23 CST 2017<br>  按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间的date命令如下所示：<br>  [root@linuxprobe ~]# date “+%Y-%m-%d %H:%M:%S”<br>  2017-08-24 16:29:12<br>  将系统的当前时间设置为2017年9月1日8点30分的date命令如下所示：<br>  [root@linuxprobe ~]# date -s “20170901 8:30:00”<br>  Fri Sep 1 08:30:00 CST 2017<br>  再次使用date命令并按照默认的格式查看当前的系统时间，如下所示：<br>  [root@linuxprobe ~]# date<br>  Fri Sep 1 08:30:01 CST 2017<br>  date命令中的参数%j可用来查看今天是当年中的第几天。这个参数能够很好地区分备份时间的新旧，即数字越大，越靠近当前时间。该参数的使用方式以及显示结果如下所示。<br>  [root@linuxprobe ~]# date “+%j”<br>  244</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>3.reboot 命令 : 用于重启(必须root管理员才可以用)</p>
<ul>
<li>格式为: reboot</li>
</ul>
</li>
<li><p>4.poweroff 命令 : 用于关闭系统(必须root管理员才可以用)</p>
<ul>
<li>格式为 : poweroff</li>
</ul>
</li>
<li><p>5.wget命令: 用于在终端中下载网络文件</p>
<ul>
<li><p>格式为 : wget [参数] 下载地址</p>
<ul>
<li><p>wget命令的参数与作用</p>
<ul>
<li><p>-b : 后台下载模式<br>-P : 下载到指定目录<br>-t : 最大尝试次数<br>-c : 断点续传<br>-p : 下载页面内所有资源,包括图片,视频等<br>-r : 递归下载</p>
<ul>
<li><p>例子</p>
<p>  尝试使用wget命令从本书的配套站点中下载本书的最新pdf格式电子文档，这个文件的完整路径为<a href="https://www.linuxprobe.com/docs/LinuxProbe.pdf" target="_blank" rel="noopener">https://www.linuxprobe.com/docs/LinuxProbe.pdf</a>，执行该命令后的下载效果如下：<br>  [root@linuxprobe ~]# wget <a href="https://www.linuxprobe.com/docs/LinuxProbe.pdf" target="_blank" rel="noopener">https://www.linuxprobe.com/docs/LinuxProbe.pdf</a><br>  –2017-08-24 19:30:12 – <a href="https://www.linuxprobe.com/docs/LinuxProbe.pdf" target="_blank" rel="noopener">https://www.linuxprobe.com/docs/LinuxProbe.pdf</a><br>  Resolving <a href="http://www.linuxprobe.com" target="_blank" rel="noopener">www.linuxprobe.com</a> (<a href="http://www.linuxprobe.com" target="_blank" rel="noopener">www.linuxprobe.com</a>)… 220.181.105.185<br>  Connecting to <a href="http://www.linuxprobe.com" target="_blank" rel="noopener">www.linuxprobe.com</a> (<a href="http://www.linuxprobe.com)|220.181.105.185|:80...connected">www.linuxprobe.com)|220.181.105.185|:80...connected</a>.<br>  HTTP request sent, awaiting response… 200 OK<br>  Length: 45948568 (44M) [application/pdf]<br>  Saving to: ‘LinuxProbe.pdf’<br>  100%[===========================================&gt;] 45,948,568 32.9MB/s in 1.3s<br>  2017-08-24 19:30:14 (32.9 MB/s) - ‘LinuxProbe.pdf’ saved [45948568/45948568]<br>  接下来，我们使用wget命令递归下载<a href="https://www.linuxprobe.com/" target="_blank" rel="noopener">www.linuxprobe.com</a>网站内的所有页面数据以及文件，下载完后会自动保存到当前路径下一个名为<a href="http://www.linuxprobe.com的目录中。执行该操作的命令为wget" target="_blank" rel="noopener">www.linuxprobe.com的目录中。执行该操作的命令为wget</a> -r -p <a href="https://www.linuxprobe.com/" target="_blank" rel="noopener">https://www.linuxprobe.com</a>，该命令的执行结果如下。<br>  [root@linuxprobe ~]# wget -r -p <a href="https://www.linuxprobe.com" target="_blank" rel="noopener">https://www.linuxprobe.com</a><br>  –2017-08-24 19:31:41– <a href="https://www.linuxprobe.com/" target="_blank" rel="noopener">https://www.linuxprobe.com/</a><br>  Resolving <a href="http://www.linuxprobe.com" target="_blank" rel="noopener">www.linuxprobe.com</a>… 106.185.25.197<br>  Connecting to <a href="http://www.linuxprobe.com|106.185.25.197|:80" target="_blank" rel="noopener">www.linuxprobe.com|106.185.25.197|:80</a>… connected.<br>  HTTP request sent, awaiting response… 200 OK<br>  Length: unspecified [text/html]<br>  Saving to: ‘<a href="http://www.linuxprobe.com/index.html&#39;" target="_blank" rel="noopener">www.linuxprobe.com/index.html&#39;</a><br>  ………………省略下载过程………………</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.ps命令: 用于查看系统中的进程状态</p>
<ul>
<li><p>格式为:ps [参数]</p>
<ul>
<li><p>常见参数及作用</p>
<ul>
<li>-a : 显示所有进程<br>-u : 用户以及其他详细信息<br>-x : 显示没有控制终端的进程</li>
</ul>
</li>
</ul>
</li>
<li><p>常见的进程状态</p>
<ul>
<li><p>ps -aux后的进程内容解释</p>
<p>  USER : 进程所有者<br>  PID : 进程ID号<br>  %CPU : 运算器占用率<br>  %MEM : 内存占用率<br>  VSZ : 虚拟内存使用量(单位KB)<br>  RSS : 占用的固定内存量(单位KB)<br>  TTY : 所在终端<br>  STAT : 进程状态<br>  START : 被启动的时间<br>  TIME : 实际使用的CPU的时间<br>  COMMAND : 命令与参数</p>
</li>
<li><p>R(运行) : 正在运行或在运行队列中等待  </p>
<p>S(中断) : 进程进入休眠中,当某个条件形成后或者接收到信号时,则脱离该状态  </p>
<p>D(不可中断) : 进程不响应系统异步信号,即时用kill命令也不能将其中断  </p>
<p>Z(僵死) : 进程已经终止,但进程描述符依然存在,知道父进程调用wait4()系统函数后将进程释放 <br>T(停止) : 进程收到停止信号后停止运行</p>
</li>
</ul>
</li>
<li><p>Tips:Linux中的命令长格式和长格式不能合并与短格式也不能,但是,短格式和短格式就可以合并,并保留一个-号</p>
</li>
</ul>
</li>
<li><p>7.top命令: 动态的坚实进程活动与系统负载等信息,<strong>类似强化版的Windows任务管理器</strong></p>
<ul>
<li><p>格式为: top</p>
<ul>
<li><p>执行top命令后,前五行是系统整体统计信息,含义如下</p>
<p>  第一行:负载和基本信息</p>
<p>  系统时间 | 运行时间 | 登录终端数 | 系统负载:三个数值 : 1/5/15分钟内的平均值,数值越小意味着负载越低</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>            第二行:进程  

            进程总数 | 运行中的进程 | 睡眠中的进程 | 停止的进程数 | 僵死的进程数  

            第三行:CPU占用比  

            us (user space) 用户占用资源百分比  
            sy (sysctl)系统内核占用资源百分比  
            ni ()改变过优先级的进程资源百分比  
            id (idolt)空闲的资源百分比  
            wa (wait) IO等待占用CPU的百分比  
            hi (Hardware IRQ) 硬中断占用CPU的百分比  
            si (Software Interrupts) 软中断占用CPU的百分比  
            st (Steal Time) 虚拟主机被hypervisor投去的CPU时间  

            第四行:物理内存  

            物理内存总量(total) | 内存使用量(used) | 内存空闲量(free) | 作为内核缓存的内存量(buff cache)  

            第五行:swap交换分区信息  

            虚拟内存总量 | 虚拟内存使用量 | 虚拟内存空闲量 | 已被提前加载的内存量  

            第七行:  

            PID : 进程id  
            USER : 进程所有者   
            PR : 进程优先级  
            NI : nice值,负值高优先,正值表示低优先级  
            VIRT : 进程使用的虚拟内存总量  
            RES : 进程使用的,未被换出的物理内存大小  
            SHR : 共享内存大小  
            S : 进程状态   
            %CPU : 上次更新到现在的CPU时间占用百分比  
            %MEM : 进程使用的物理内存百分比  
            TIME+ :进程使用的CPU时间总计,单位1/100秒  
            COMMAND : 进程名称(命令名/命令行)

- 8.pidof命令:用于查询某个指定服务器的PID值

    - 格式为 : pidof [参数] [服务名称]

        - 例子

            每个进程的进程号码值（PID）是唯一的，因此可以通过PID来区分不同的进程。例如，可以使用如下命令来查询本机上sshd服务程序的PID：


            [root@linuxprobe ~]# pidof sshd  
            2156

- 9.kill命令:用于终止某个指定的PID服务进程

    - 格式为 : kill [参数] [进程PID]

- 10.killall命令 : 终止某个指定名称的服务所对应的全部进程 

    通常来讲，复杂软件的服务程序会有多个进程协同为用户提供服务，如果逐个去结束这些进程会比较麻烦，此时可以使用killall命令来批量结束某个服务程序带有的全部进程。下面以httpd服务程序为例，来结束其全部进程。由于RHEL7系统默认没有安装httpd服务程序，因此大家此时只需看操作过程和输出结果即可，等学习了相关内容之后再来实践。

    - 格式为 : killall [参数] [服务名称]

    - Tips

        如果我们在系统终端中执行一个命令后想立即停止它，**可以同时按下Ctrl + C组合键（**生产环境中比较常用的一个快捷键），这样将立即终止该命令的进程。

        或者，如果有些命令在执行时不断地在屏幕上输出信息，影响到后续命令的输入，则可以在执行命令时在**末尾添加上一个&amp;符号**，这样命令将进入系统后台来执行。</code></pre><ul>
<li><p>2.4 系统状态检测命令</p>
<ul>
<li><ol>
<li><p>ifconfig命令 : 用于获取网卡配置与网络状态等信息</p>
<ul>
<li><p>格式为 :ifconfig [网络设备] [参数]</p>
<ul>
<li><p>使用ifconfig查看网卡配置与网络状态信息,主要看</p>
<ul>
<li>网卡名称 <br>inet参数后的iP地址 <br>ether参数后的网卡物理地址(又称MAC地址) <br>RX,TX接收与发送数据包的个数及累计流量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li><p>uname命令 : 查看系统内核与系统版本等信息</p>
<ul>
<li><p>格式为 : uname [-a]</p>
<p> 在使用uname命令时，一般会固定搭配上-a参数来完整地查看当前<strong>系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称</strong>等信息。</p>
</li>
<li><p>Tips : 如需查看系统详细版本信息,徐亚查看redhat-release文件</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>3.uptime命令 : 查看系统负载信息</p>
<p>  uptime命令真的很棒，<strong>它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息</strong>。</p>
<p>  平均负载值指的是系统在最近1分钟、5分钟、15分钟内的压力情况（下面加粗的信息部分）；负载值越低越好，<strong>尽量不要长期超过1，在生产环境中不要超过5。</strong></p>
<ul>
<li><p>格式为 : uptime</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li><p>4.free命令 : 用于查看当前系统中内存的使用量信息</p>
<ul>
<li><p>格式为 : free [-h]</p>
<ul>
<li><p>执行后输出的信息解析</p>
<p>  total : 内存总量<br>  used : 已用量<br>  free : 可用量<br>  shared : 进程共享的内存量<br>  buffers : 磁盘缓存的内存量<br>  cached : 缓存的内存量<br>  avaiable :还可以被应用程序使用的物理内存大小  </p>
<p>  free与availalbe的区别:  </p>
<p>  <a href="https://www.jianshu.com/p/2ffeb3a3aa90" target="_blank" rel="noopener">https://www.jianshu.com/p/2ffeb3a3aa90</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>5.who命令 : 查看当前登录主机的用户终端信息</p>
<p>  这三个简单的字母可以快速显示出所有正在登录本机的用户的名称以及他们正在开启的终端信息</p>
<ul>
<li>格式为 : who [参数]</li>
</ul>
</li>
<li><p>6.last命令 : 查看所有系统登录记录</p>
<p>  使用last命令可以查看本机的登录记录。但是，由于这些信息都是以日志文件的形式保存在系统中，因此黑客可以很容易地对内容进行篡改。千万不要单纯以该命令的输出信息而判断系统有无被恶意入侵！</p>
<ul>
<li>格式为 : last [参数]</li>
</ul>
</li>
<li><p>7.history命令 : 显示历史执行过的命令</p>
<p>  执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，还可以自定义/etc/profile文件中的HISTSIZE变量值。在使用history命令时，如果使用-c参数则会清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。</p>
<ul>
<li><p>格式为 : history [-c]</p>
</li>
<li><p>Tips</p>
<p>  <strong>历史命令会被保存到用户家目录中的.bash_history文件中</strong>。</p>
<p>  <strong>Linux系统中以点（.）开头的文件均代表隐藏文件</strong>，这些文件大多数为系统服务文件，可以用cat命令查看其文件内容</p>
</li>
</ul>
</li>
<li><p>8.sosreport命令: 用于收集系统配置及架构信息并输出诊断文档</p>
<p>  当Linux系统出现故障需要联系技术支持人员时，大多数时候都要先使用这个命令来简单收集系统的运行状态和服务配置信息，以便让技术支持人员能够远程解决一些小问题，亦或让他们能提前了解某些复杂问题。在下面的输出信息中，加粗的部分是收集好的资料压缩文件以及校验码，将其发送给技术支持人员即可</p>
<ul>
<li>格式为 : sosereport</li>
</ul>
</li>
</ul>
</li>
<li><p>2.5 工作目录切换命令</p>
<ul>
<li><p>1.pwd命令 : 显示用户当前所处的工作目录</p>
<ul>
<li>格式为 : pwd [选项]</li>
</ul>
</li>
<li><p>2.cd命令 : 用于切换工作路径</p>
<ul>
<li><p>格式为 : cd [目录名称]</p>
<ul>
<li><p>cd - : 返回到上一次所处的目录</p>
</li>
<li><p>cd.. : 进入上级目录</p>
</li>
<li><p>cd ~ :切换到当前用户的家目录</p>
</li>
<li><p>cd ~username : 切换到其他用户的家目录</p>
</li>
<li><p>cd /路径:切换指定目录</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>3.ls命令 : 用于显示目录中的文件信息</p>
<ul>
<li><p>格式为 : ls [选项] [文件]</p>
<ul>
<li><p>ls -a :查看全部文件(包括隐藏文件)</p>
</li>
<li><p>ls -l : 查看文件属性大小等信息</p>
</li>
<li><p>ls -al : 查看目录所有文件并输出这些文件的属性信息</p>
</li>
<li><p>ls -ld : 查看目录属性信息</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.6 文本文件编辑命令</p>
<ul>
<li><p>1.cat命令:用于查看纯文本文件(内容较少的)</p>
<ul>
<li><p>格式为:cat [选项] [文件]</p>
<ul>
<li>-n : 显示行号</li>
</ul>
</li>
</ul>
</li>
<li><p>2.more命令:用于查看纯文本文件(内容较多的)</p>
<ul>
<li>格式为:more [选项] [文件]</li>
</ul>
</li>
<li><p>3.head命令:用于查看纯文本文档的前N行</p>
<ul>
<li><p>格式为:head [选项] [文件]</p>
<ul>
<li>-n num : 要查看多少行</li>
</ul>
</li>
</ul>
</li>
<li><p>4.tail命令:用于查看文本的后N行<strong>或持续刷新命令</strong></p>
<ul>
<li><p>格式为:tail [选项] [文件]</p>
<ul>
<li><p>-n num : 要查看后多少行</p>
</li>
<li><p>-f 文件名 : 查看实时更新的文件</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="http://5.tr" target="_blank" rel="noopener">5.tr</a>命令:用于替换文文件中的字符</p>
<p>  在很多时候，我们想要快速地替换文本中的一些词汇，又或者把整个文本内容都进行替换，如果进行手工替换，难免工作量太大，尤其是需要处理大批量的内容时，进行手工替换更是不现实。这时，就可以先使用cat命令读取待处理的文本，然后通过管道符（详见第3章）把这些文本内容传递给tr命令进行替换操作即可。例如，把某个文本内容中的英文全部替换为大写：</p>
<ul>
<li>格式为:tr [原始字符] [目标字符]</li>
</ul>
</li>
<li><p>6.wc命令:用于统计指定文本的行数/字数/字节数</p>
<ul>
<li><p>格式为:wc [参数] 文本</p>
<ul>
<li><p>-l :只显示行数</p>
</li>
<li><p>-w : 只显示单词数</p>
</li>
<li><p>-c : 只显示字数</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>7.stat命令:用于查看文件的具体存储信息和时间等信息</p>
<p>  stat命令可以用于查看文件的存储信息和时间等信息，命令stat anaconda-ks.cfg会显示出文件的三种时间状态（已加粗）：Access、Modify、Change</p>
<ul>
<li>格式为:stat 文件名称</li>
</ul>
</li>
<li><p>8.cut命令:用于按”列”提取文本字符</p>
<ul>
<li><p>格式为:cut [参数] 文本</p>
<ul>
<li><p>-f num :查看的列数</p>
</li>
<li><p>-d : 设置间隔符号</p>
</li>
<li><p>例子</p>
<p>  [root@linuxprobe ~]# head -n 2 /etc/passwd<br>  root:x:0:0:root:/root:/bin/bash<br>  bin:x:1:1:bin:/bin:/sbin/nologin  </p>
<p>  [root@linuxprobe ~]# cut -d: -f1 /etc/passwd  </p>
<p>  root<br>  bin<br>  daemon<br>  adm</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>9.diff命令:用于比较多个文本文件的差异</p>
<ul>
<li><p>格式为:diff [参数] 文件</p>
<ul>
<li><p>—brief:确认两个文件是否不同</p>
</li>
<li><p>-c:详细比较多个文件的差异之处</p>
<ul>
<li>不同的一行开头会有!号</li>
</ul>
</li>
<li><p>例子</p>
<p>  接下来使用diff –brief命令显示比较后的结果，判断文件是否相同：<br>  [root@linuxprobe ~]# diff –brief diff_A.txt diff_B.txt<br>  Files diff_A.txt and diff_B.txt differ<br>  最后使用带有-c参数的diff命令来描述文件内容具体的不同：<br>  [root@linuxprobe ~]# diff -c diff_A.txt diff_B.txt<br>  *** diff_A.txt 2017-08-30 18:07:45.230864626 +0800<br>  — diff_B.txt 2017-08-30 18:08:52.203860389 +0800  </p>
<hr>
<p>  <strong>* 1,5 **</strong><br>  ! Welcome to linuxprobe.com<br>  Red Hat certified<br>  ! Free Linux Lessons<br>  Professional guidance<br>  Linux Course<br>  — 1,7 —-<br>  ! Welcome tooo linuxprobe.com<br>  !<br>  Red Hat certified<br>  ! Free Linux LeSSonS<br>  ! ////////…..////////<br>  Professional guidance<br>  Linux Course</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.7 文件目录管理命令</p>
<ul>
<li><p>1.touch命令:用于创建空白文件或设置文件的时间</p>
<ul>
<li><p>格式为:touch [参数] [文件]</p>
<ul>
<li><p>-a : 仅修改”读取时间”(atime)</p>
</li>
<li><p>-m : 仅修改”修改时间”(mtime)</p>
</li>
<li><p>-d : 同时修改atime 与 mtime</p>
</li>
</ul>
</li>
<li><p>例子:修改文件时间</p>
<p>  接下来，我们先使用ls命令查看一个文件的修改时间，然后修改这个文件，最后再通过touch命令把修改后的文件时间设置成修改之前的时间（很多黑客就是这样做的呢）：<br>  [root@linuxprobe ~]# ls -l anaconda-ks.cfg<br>  -rw——-. 1 root root 1213 May  4 15:44 anaconda-ks.cfg<br>  [root@linuxprobe ~]# echo “Visit the LinuxProbe.com to learn linux skills” &gt;&gt; anaconda-ks.cfg<br>  [root@linuxprobe ~]# ls -l anaconda-ks.cfg<br>  -rw——-. 1 root root 1260 Aug  2 01:26 anaconda-ks.cfg<br>  [root@linuxprobe ~]# touch -d “2017-05-04 15:44” anaconda-ks.cfg<br>  [root@linuxprobe ~]# ls -l anaconda-ks.cfg<br>  -rw——-. 1 root root 1260 May  4 15:44 anaconda-ks.cfg</p>
</li>
</ul>
</li>
<li><p>2.mkdir命令:用于创建空白目录</p>
<ul>
<li><p>格式为:mkdir [选项] [目录]</p>
<ul>
<li>-p :递归创建具有嵌套叠层关系的文件目录</li>
</ul>
</li>
</ul>
</li>
<li><p>3.cp命令:用于复制文件或目录</p>
<ul>
<li><p>格式:cp [选项] 源文件 目标文件</p>
<ul>
<li><p>参数及作用</p>
<ul>
<li>-p 保留原始文件的属性<br>-d 若对象为”链接文件”,则保留该”链接文件”的属性<br>-r 递归持续复制(用于目录)<br>-i 若目标文件存在则询问是否覆盖<br>-a 相当于 -pdr (p\d\r为上述参数)</li>
</ul>
</li>
<li><p>复制的三种情况</p>
<ul>
<li>1.如果目标文件时目录,则会把源文件复制到该目录中<br>2.如果目标也是普通文件,则会询问是否要覆盖它<br>3.如果目标文件不存在,则执行正常的复制操作</li>
</ul>
</li>
<li><p>例子</p>
<p>  接下来，使用touch创建一个名为install.log的普通空白文件，然后将其复制为一份名为x.log的备份文件，最后再使用ls命令查看目录中的文件：<br>  [root@linuxprobe ~]# touch install.log<br>  [root@linuxprobe ~]# cp install.log x.log<br>  [root@linuxprobe ~]# ls<br>  install.log x.log</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>4.mv命令:用于剪切文件或将文件重命名</p>
<p>  剪切操作不同于复制操作，因为它会默认把源文件删除掉，只保留剪切后的文件。如果在同一个目录中对一个文件进行剪切操作，其实也就是对其进行重命名</p>
<ul>
<li><p>格式: mv [选项] 源文件 [目标路径|目标文件名]</p>
</li>
<li><p>例子</p>
<p>  [root@linuxprobe ~]# mv x.log linux.log<br>  [root@linuxprobe ~]# ls<br>  install.log linux.log</p>
</li>
</ul>
</li>
<li><p>5.rm命令:用于删除文件或目录</p>
<ul>
<li><p>格式: rm [选项] 文件</p>
<ul>
<li><p>参数</p>
<ul>
<li><p>-r 递归删除</p>
</li>
<li><p>-f 不提示确认</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>6.dd命令:用于按照指定大小和个数的数据块来复制文件或转换文件</p>
<ul>
<li><p>参数</p>
<ul>
<li>if 输入文件的名称 of 输出文件的名称 bs 设置每个”块”的大小<br>count 设置要复制”块”的个数</li>
</ul>
</li>
<li><p>格式:dd [参数]</p>
</li>
<li><p>例子</p>
<ul>
<li><p>从/dev/zero取出一块560M大小的数据块</p>
<p>  例如我们可以用dd命令从/dev/zero设备文件中取出一个大小为560MB的数据块，然后保存成名为560_file的文件。在理解了这个命令后，以后就能随意创建任意大小的文件了：</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>            [root@linuxprobe ~]# dd if=/dev/zero of=560_file count=1 bs=560M  
            1+0 records in  
            1+0 records out  
            587202560 bytes (587 MB) copied, 27.1755 s, 21.6 MB/s

        - 把光驱设备中的光盘制作成iso格式的镜像文件

            dd命令的功能也绝不仅限于复制文件这么简单。如果您想把光驱设备中的光盘制作成iso格式的镜像文件，在Windows系统中需要借助于第三方软件才能做到，但在Linux系统中可以直接使用dd命令来压制出光盘镜像文件，将它变成一个可立即使用的iso镜像：


            [root@linuxprobe ~]# dd if=/dev/cdrom of=RHEL-server-7.0-x86_64-LinuxProbe.Com.iso  
            7311360+0 records in  
            7311360+0 records out  
            3743416320 bytes (3.7 GB) copied, 370.758 s, 10.1 MB/s

- 7.file命令:用于查看文件的类型

    - 格式为:file 文件名

    - 在Linux系统中，由于文本、目录、设备等所有这些一切都统称为文件，而我们又不能单凭后缀就知道具体的文件类型，这时就需要使用file命令来查看文件类型了。</code></pre><ul>
<li><p>2.8 打包压缩与搜索命令</p>
<ul>
<li><p>1.tar命令:用于对文件进行打包压缩或解压</p>
<ul>
<li><p>格式为:tar [选项] [文件]</p>
<ul>
<li><p>参数与作用</p>
<ul>
<li><p>-c 创建压缩文件<br>-x 解开压缩文件<br>-t 查看压缩包内的文件<br>-z 用Gzip压缩或解压<br>-j 用bzip2压缩或解压<br>-v 显示压缩或解压的过程<br>-f 目标文件名<br>-p 保留原始的权限和属性<br>-P 使用绝对路径来解压<br>-C 指定压缩到的目录</p>
</li>
<li><p>一般使用参数 <strong>-czvf</strong> 压缩包名称.tar.gz 命令压缩文件  |  使用参数 <strong>-xzvf</strong> 压缩包名称.tar.gz解压文件</p>
</li>
<li><p>注意<br>c/x/t只能用一个<br>f必须放到参数最后一个</p>
</li>
</ul>
</li>
<li><p>例子</p>
<p>  下面我们来逐个演示下打包压缩与解压的操作。先使用tar命令把/etc目录通过gzip格式进行打包压缩，并把文件命名为etc.tar.gz：</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>            [root@linuxprobe ~]# tar czvf etc.tar.gz /etc  
            tar: Removing leading `/&apos; from member names  
            /etc/  
            /etc/fstab  
            /etc/crypttab  
            /etc/mtab  
            /etc/fonts/  
            /etc/fonts/conf.d/  
            /etc/fonts/conf.d/65-0-madan.conf  
            /etc/fonts/conf.d/59-liberation-sans.conf  
            /etc/fonts/conf.d/90-ttf-arphic-uming-embolden.conf  
            /etc/fonts/conf.d/59-liberation-mono.conf  
            /etc/fonts/conf.d/66-sil-nuosu.conf  
            ………………省略部分压缩过程信息………………



            接下来将打包后的压缩包文件指定解压到/root/etc目录中（先使用mkdir命令来创建/root/etc目录）：


            [root@linuxprobe ~]# mkdir /root/etc  
            [root@linuxprobe ~]# tar xzvf etc.tar.gz -C /root/etc  
            etc/  
            etc/fstab  
            etc/crypttab  
            etc/mtab  
            etc/fonts/  
            etc/fonts/conf.d/  
            etc/fonts/conf.d/65-0-madan.conf  
            etc/fonts/conf.d/59-liberation-sans.conf  
            etc/fonts/conf.d/90-ttf-arphic-uming-embolden.conf  
            etc/fonts/conf.d/59-liberation-mono.conf  
            etc/fonts/conf.d/66-sil-nuosu.conf  
            etc/fonts/conf.d/65-1-vlgothic-gothic.conf  
            etc/fonts/conf.d/65-0-lohit-bengali.conf  
            etc/fonts/conf.d/20-unhint-small-dejavu-sans.conf  
            ………………省略部分解压过程信息………………

- 2.grep命令:用于在文本文件中执行关键词搜索,并显示匹配的结果

    - 格式为:grep [选项] [文件]

        - 参数与作用

            - -b 将可执行文件(binary)当做文本文件(text)来搜索  
              -c 仅显示找到的行数  
              -i 忽略大小写 -n 显示行号  
              -v 反向选择 —  列出没有’关键词’的行

- 3.find命令:用于按照指定条件来查找文件

    本书中曾经多次提到“Linux系统中的一切都是文件”，接下来就要见证这句话的分量了。在Linux系统中，搜索工作一般都是通过find命令来完成的，它可以使用不同的文件特性作为寻找条件（如文件名、大小、修改时间、权限等信息），一旦匹配成功则默认将信息显示到屏幕上

    - 格式为:find [查找路径] 寻找条件 操作

        - 参数与作用

            - -name 匹配名称  
              -perm 匹配权限(mode为完全匹配,-mode为包含即可)  
              -user 匹配所有者 -group 匹配所有组  
              -mtime -n +n 匹配修改内容的时间(-n指n天以内,+n指n天以前)  
              -atime -n +n 匹配访问文件的时间(-n指n天以内,+n指n天以前) -ctime -n +n 匹配修改文件权限的时间 (-n指n天以内,+n指n天以前) -nouser 匹配无所有者的文件 -nogroup 匹配无所有组的文件 -newer f1 !f2 匹配比文件f1新单比f2旧的文件 —type b/d/c/p/l/f 匹配文件类型(后面的字母一次表示块设备\目录\字符设备\管道\链接文件\文本文件 -size 匹配文件的大小(+50KB为查找超过50KB的文件,而-50KB为查找下雨50KB的文件 -prune 忽略某个目录 -exec ……{}\; 后面可跟用于进一步处理搜索结果的命令

            - -exec:这里需要重点讲解一下-exec参数重要的作用。这个参数用于把find命令搜索到的结果交由紧随其后的命令作进一步处理，它十分类似于第3章将要讲解的管道符技术，并且由于find命令对参数的特殊要求，因此虽然exec是长格式形式，但依然只需要一个减号（-）

        - 例子:find /etc -name &quot;host*&quot; -print</code></pre><h3 id="第四章：-Vim编辑器语Shell命令"><a href="#第四章：-Vim编辑器语Shell命令" class="headerlink" title="第四章： Vim编辑器语Shell命令"></a>第四章： Vim编辑器语Shell命令</h3><p><a href="https://www.linuxprobe.com/chapter-04.html" target="_blank" rel="noopener">https://www.linuxprobe.com/chapter-04.html</a></p>
<ul>
<li><p>判断用户的参数-4.2.3</p>
<ul>
<li><p>使用条件表达式：[ 注意这两遍都有空格 ] </p>
<ul>
<li><p>按测试对象来划分</p>
<ul>
<li><p>文件测试语句 </p>
<ul>
<li><p>文件测试参数</p>
<p>  -d 测试文件是否为目录类型<br>  -e 测试文件是否存在<br>  -f 判断是否为一般文件<br>  -r 测试当前用户是否有权限读取<br>  -w 测试当前用户是否有权限写入<br>  -x 测试当前用户是否有权限</p>
</li>
<li><p>判断文件是否存在权限是否满足等情况的运算符</p>
</li>
</ul>
</li>
<li><p>逻辑测试语句</p>
<ul>
<li><p>逻辑‘<strong>与</strong>’运算符：<strong>&amp;&amp; ，</strong> 它表示，当前面的命令执行<strong>成功后才执行</strong>它后面的命令</p>
</li>
<li><p>逻辑‘<strong>或</strong>’运算符：<strong>||</strong>，它表示，当前面的命令<strong>执行失败后，才会执行</strong>它后 面的命令</p>
</li>
<li><p>逻辑‘<strong>非</strong>’运算符：<strong>！</strong>，它表示，<strong>把条件判断结果取相反值</strong> ，如果原来的测试结果是正确的,则将其变成错误的,错误的变成正确的.</p>
<ul>
<li><p>例如</p>
<p>  [ $USER = root ] 是判断当前用户是否为管理员</p>
<p>  而  </p>
<p>  [ $USER != root ] 就是判断当前用户是否非管理员</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>整数值比较语句</p>
<ul>
<li><p>仅仅是对<strong>数字</strong>的操作,不能将数字与文件或字符串一起操作,而且不能想当然的使用日常生活中的运算符号(=&gt;&lt;=-)等,</p>
<ul>
<li><p>可用的整数比较</p>
<p>  -eq 是否等于  (equal)<br>  -ne 是否不等于 (not equal)<br>  -gt 是否大于 (Greater than)<br>  -lt 是否小于(Less than)<br>  -le 是否等于或小于(Less than or Equal)<br>  -ge是否大于或等于(Greater than or Equal)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串比较语句</p>
<ul>
<li><p>什么是字符串?</p>
<p>  简称’串’,是有序的字符序列,数据元素为字符的线性表,是一种数据的逻辑结构.</p>
</li>
<li><p>常用的字符串比较运算符</p>
<p>  = 比较字符串内容是否相同<br>  != 比较字符串内容是否不同<br>  -z 判断字符串内容是否为空</p>
</li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li><p>使用free/grep与awk找出free命令中可用内存中的信息</p>
<ul>
<li><p>先使用free -m命令查看内存使用量情况（单位为MB），然后通过grep Mem:命令过滤出剩余内存量的行，再用awk ‘{print $4}’命令只保留第四列，最后用FreeMem=<code>语句</code>的方式把语句内执行的结果赋值给变量。</p>
<p>  [root@linuxprobe ~]# FreeMem=<code>free -m | grep Mem: | awk &#39;{print $4}&#39;</code><br>  [root@linuxprobe ~]# echo $FreeMem </p>
<ul>
<li><p><strong>grep命令</strong>:<strong>就像Ctrl+F,是字符查找工具</strong>,是一个利用正则表达式进行全局搜索的工具,grep会在文本文件中按照指定的正则表达式进行全局搜索,<strong>并将搜索出的行打印出来</strong></p>
<p>  grep命令全称:Global search Regular Expression and Print out the line</p>
<ul>
<li><p><strong>-i:不区分大小写</strong></p>
</li>
<li><p><strong>-n:显示所在行</strong></p>
</li>
<li><p><strong>—color:高亮显示</strong></p>
<ul>
<li><strong>—color与—color=auto效果相同</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>awk命令:</strong>把文件逐行读入,以空格为默认分隔符将每行切片</p>
<ul>
<li><strong>使用方法: awk ‘{pattern+action}’ {filenames}</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>流程控制语句 - 4.3</p>
<p>  尽管现在可以使用：Linux命令、管道符、重定向、以及条件测试语句来编写简单的Shell脚本，但这些脚本不适用于生产环境。  </p>
<p>  原因是：它不能根据真实工作需求来调整具体的执行命令，也不能根据某些条件实现自动循环执行。</p>
<ul>
<li><p>if条件测试语句</p>
<ul>
<li><p>技术上if语句结构分为</p>
<ul>
<li><p>单分支组成</p>
<p>  只在条件成立后才执行预设的命令  </p>
<p>  相当于口语的:如果…那么…</p>
<ul>
<li><p>if</p>
</li>
<li><p>then</p>
</li>
<li><p>fi</p>
</li>
<li><p>例子</p>
<p>  单分支的if语法格式</p>
<p>  if 条件测试操作:如果目录不存在</p>
<pre><code>then 命令序列:就创建该目录</code></pre><p>  fi  </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>                实践:

                使用 vim mkcdrom.sh 创建一个shell脚本

                在头部输入解释器的位置:  
                #!/bin/bash  
                DIR=“media/cdrom”  
                if [ ! -e $DIR ]  
                then  
                mkdir -p $DIR  
                fi  

                然后再终端执行:
                bash mkcdrom.sh 执行脚本

                最后可以使用:
                ls -d /media/cdrom   
                来验证是否成功执行

        - 双分支组成

            它执行一次条件匹配判断,如果与条件匹配,则去执行相应的预设命令;

            反之则去执行不匹配的预设命令  

            相当于口语 : 如果…那么…或者...那么

            - if

            - then

            - else

            - fi

            - 例子

                if双分支语法结构:  

                if 条件测试操作:能够ping通  
                    then 命令序列1:提示服务器正常功能  
                    else 命令序列2:报警服务器出现问题  
                fi  


                实践例子:通过ping命令测试与对方主机的网络联通性  

                首先:  
                vim chkhost.sh 创建脚本文件  

                头部惯例写入:  
                #!/bin/bash  
                然后写入  
                ping -c 3 -i 0.2 -W 3 $1 &amp;&gt; /dev/null  
                if [ $? -eq 0 ]   
                then  
                echo “Host $1 is On-line.”  
                else  
                echo “Host $1 is Off-line.”  
                fi  

                最后在终端中输入:  
                bash chkhost.sh 测试的主机iP地址

        - 多分支

            进行多次条件判断,这多次判断中的任何一项在匹配成功后都会执行相应的预设命令.  


            语法格式:  

            if 条件测试操作1 : 分数为85~100之间  
                then 命令序列1 : 判断为优秀  
            elif 条件测试操作2 : 分数为70~84之间  
                then 命令序列2 : 判断为合格  
            else  
                命令序列3 : 判断为不合格  
            fi

            - if

            - then

            - elif

            - then

            - else

            - fi

            - 例子

                多分枝语法结构：  

                if    条件测试操作1：分数为85～100之间

                    then 命令序列1：判为优秀

                elif 条件测试操作2: 分数为70～84之间

                    then 命令序列2:判为合格


                else   
                    命令序列3: 判为不合格  

                fi

- for条件循环语句

    for循环语句允许脚本一次读取多个信息，然后逐一对信息进行操作处理，但要处理的数据有范围时，使用for循环语句再适合不过了。

    for循环语句语法格式：  

    for 变量名-用户名 in 取值列表-列表文件  
    do  
        命令序列-创建用户并设置密码  
    done

    - 参考

        - **read命令**用来读取用户输入信息的命令,能把接收到的用户输入信息赋值给后面的指定变量,**-p**参数用于向用户显示一定的提示信息

        - ping -c 3 -i 0.2 -W 3  
          : -c是次数 -i 是间隔 -W 限制时间

- while条件循环语句

    while条件循环语句是一种让脚本根据某些条件来重复执行命令的语句，它的循环结构往往在执行前并不确定最终执行的次数，完全不同于for循环语句中有目标、有范围的使用场景。while循环语句通过判断条件测试的真假来决定是否继续执行命令，若条件为真就继续执行，为假就结束循环。while语句的语法格式如图4-21所示。

    while 条件测试操作:为猜中正确价格  
    do  
    命令序列:反复猜测商品价格  

    done

    - 例子

        [root@linuxprobe ~]# vim Guess.sh  
        #!/bin/bash  
        PRICE=$(expr $RANDOM % 1000)  
        TIMES=0  
        echo &quot;商品实际价格为0-999之间，猜猜看是多少？&quot;
        while true  
        do  
        read -p &quot;请输入您猜测的价格数目：&quot; INT
        let TIMES++  
        if [ $INT -eq $PRICE ] ; then  
        echo &quot;恭喜您答对了，实际价格是 $PRICE&quot;
        echo &quot;您总共猜测了 $TIMES 次&quot;
        exit 0  
        elif [ $INT -gt $PRICE ] ; then  
        echo &quot;太高了！&quot;
        else  
        echo &quot;太低了！&quot;
        fi  
        done

    - 

        - 知识点

            - 变量=$() 与  `` 效果一样

            - expr命令:expr命令是一个手工命令行计数器,用于在UNIX/LINUX下求表达式变量的值,一般用于整数值,也可用于字符串.

                **实例**  
                1、计算字串长度
                &gt; expr length “this is a test”
                 14
                2、抓取字串
                &gt; expr substr “this is a test” 3 5
                is is
                3、抓取第一个字符数字串出现的位置
                &gt; expr index &quot;sarasara&quot;  a
                 2
                4、整数运算
                 &gt; expr 14 % 9
                 5
                 &gt; expr 10 + 10
                 20
                 &gt; expr 1000 + 900
                 1900
                 &gt; expr 30 / 3 / 2
                 5
                 &gt; expr 30 \* 3 (使用乘号时，必须用反斜线屏蔽其特定含义。因为shell可能会误解显示星号的意义)
                 90
                 &gt; expr 30 * 3
                 expr: Syntax error

            - let命令:let命令是BASH中用于计算的工具 , 语法格式: let arg [arg…] , arg是要执行的表达式

                - 自加操作: let no++

                - 自减操作: let no--

                - 简写形式: let not+=10 , let no-=20,分别等同于let no=no+10 , let no = no-20

            - exit命令:用于退出当前的Shell

- case条件测试语句

    如果您之前学习过C语言，看到这一小节的标题肯定会会心一笑“这不就是switch语句嘛！”是的，case条件测试语句和switch语句的功能非常相似！

    **case语句是在多个范围内匹配数据，若匹配成功则执行相关命令并结束整个条件测试；而如果数据不在所列出的范围内，则会去执行星号（*）中所定义的默认命令**。

    case语句的语法结构如图4-22所示。

    case 变量值(输入的字符) in 模式1:[a-z] | [A-Z]  
    )  
    命令序列1:提示为字母  
    ;;  
    模式2[0-9])  
    命令序列2:提示为数字  
    ;;  
    *)  
    默认命令序列:提示为特殊字符  
    esac  

    简明结构:  

    case 变量值 in 模式1  
    )  
    命令序列1  
    ;;  
    模式2  
    )  
    命令序列2  
    ;;  
    *)  
    默认命令序列:提示为特殊字符  
    esac</code></pre><ul>
<li><p>计划任务服务程序 - 4.4</p>
<p>  经验丰富的系统运维工程师可以使得Linux在无需人为介入的情况下，在指定的时间段自动启用或停止某些服务或命令，从而实现运维的自动化。尽管我们现在已经有了功能彪悍的脚本程序来执行一些批处理工作，但是，如果仍然需要在每天凌晨两点敲击键盘回车键来执行这个脚本程序，这简直太痛苦了（当然，也可以训练您的小猫在半夜按下回车键）。接下来，刘遄老师将向大家讲解如何设置服务器的计划任务服务，把周期性、规律性的工作交给系统自动完成。<br>  计划任务分为一次性计划任务与长期性计划任务，大家可以按照如下方式理解。<br>  一次性计划任务：今晚11点30分开启网站服务。<br>  长期性计划任务：每周一的凌晨3点25分把/home/wwwroot目录打包备份为backup.tar.gz。</p>
<ul>
<li><p>一次性计划任务</p>
<ul>
<li><p>使用 <strong>at</strong> 命令</p>
<ul>
<li><p>语法：at 时间</p>
<ul>
<li><p>例子</p>
<p>  [root@linuxprobe ~]# at 23:30  </p>
<p>  at &gt; systemctl restart httpd<br>  at &gt; 此处请同时按下Ctrl+d来结束编写计划任务</p>
<p>  job 3 at Mon Apr 27 23:30:00 2015<br>  [root@linuxprobe ~]# at -l<br>  3 Mon Apr 27 23:30:00 2016 a root</p>
<ul>
<li><p>回车后在：at&gt;后面输入要执行的命令</p>
<ul>
<li>再在第二行at&gt;时：安Ctrl+d来结束编写计划任务</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>查看还未执行的一次性任务</p>
<ul>
<li><p>语法：at -l</p>
</li>
<li><p>将其删除的语法：atrm 任务序号</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>长期性计划任务</p>
<p>  如果我们希望Linux系统能够周期性地、有规律地执行某些具体的任务，那么Linux系统中默认启用的crond服务简直再适合不过了。创建、编辑计划任务的命令为“crontab -e”，查看当前计划任务的命令为“crontab -l”，删除某条计划任务的命令为“crontab -r”。另外，如果您是以管理员的身份登录的系统，还可以在crontab命令中加上-u参数来编辑他人的计划任务。<br>  在正式部署计划任务前，请先跟刘遄老师念一下口诀“分、时、日、月、星期 命令”。这是使用crond服务设置任务的参数格式（其格式见表4-6）。需要注意的是，如果有些字段没有设置，则需要使用星号（*****）占位，如图4-23所示</p>
<ul>
<li><p>创建于编辑</p>
<ul>
<li>命令： crontab -e</li>
</ul>
</li>
<li><p>查看当前计划任务</p>
<ul>
<li>命令：crontab -l</li>
</ul>
</li>
<li><p>删除某条计划任务</p>
<ul>
<li>命令：crontab -r</li>
</ul>
</li>
<li><p>管理员身份登陆的系统可以编辑他人的计划任务</p>
<ul>
<li>命令：crontab -u</li>
</ul>
</li>
<li><p>设置的参数格式</p>
<ul>
<li><p>分 时 日 月 星期 命令</p>
<ul>
<li><p>例子：假设每周一、三、五的凌晨3点25分执行tar命令打包网站数据目录：使用crontab -e 在里面写入25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot</p>
<p>  [root@linuxprobe ~]# crontab -e<br>  no crontab for root - using an empty one<br>  crontab: installing new crontab  </p>
<p>  [root@linuxprobe ~]# crontab -l<br>  25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot  </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>    Tips：

    25 3 * * 1,3,5 /usr/bin/tar -czvf backup.tar.gz /home/wwwroot  

    25分 3时 * * 星期1，3，5 命令／usr/bin/tar 参数-czvf（c创建压缩、z使用gzip压缩、v显示压缩过程、f要压缩的软件包名次

    - 解释

        - [25分] [3时] [*] [*] [星期1，3，5] [命令／usr/bin/tar] [参数-czvf（c创建压缩、z使用gzip压缩、v显示压缩过程、f要压缩的软件包名次] [压缩名称xxx.tar.gz] [压缩的目录或文件]

            - *所有**命令**一定要用绝对路径的方式来写

                - 如不知绝对路径：使用whereis命令查询

            - “-”号 ， 连续周期

            - “／”号， 间隔时间

            - 除了使用 “，”号 分别表示多个时间段 ，还可用**“-”号表示一段连续的时间周期**，例如（“字段日的值为12-15则表示每月12～15日），**“／”号表示执行任务的间隔时间**，例如（“*／2”表示每个2分钟执行一次任务）

            - 每行一个计划任务

            - Tips：

                - 在crond服务中可以使用#写上注释，在以后回顾这段命令代码可以快速了解其功能

                - 计划任务中的‘分’字段必须有数值，绝对不能为空或者*号

                - “日”和“星期”字段不能同时使用，否则会发生冲突

- 如果有些字段没有设置需要使用 * 占位

- 参数说明

    字段  
    说明  
    分钟  
    取值为0～59的整数
    小时  
    取值为0～23的任意整数
    日期  
    取值为1～31的任意整数
    月份  
    取值为1～12的任意整数
    星期  
    取值为0～7的任意整数，其中0与7均为星期日
    命令  
    要执行的命令或程序脚本</code></pre><h3 id="第五章-用户身份与文件权限"><a href="#第五章-用户身份与文件权限" class="headerlink" title="第五章:用户身份与文件权限"></a>第五章:用户身份与文件权限</h3><ul>
<li><p>章节概述</p>
<p>  Linux是一个多用户、多任务的操作系统，具有很好的稳定性与安全性，在幕后保障<a href="https://www.linuxprobe.com/" target="_blank" rel="noopener">Linux系统</a>安全的则是一系列复杂的配置工作。本章将详细讲解文件的所有者、所属组以及其他人可对文件进行的读（r）、写（w）、执行（x）等操作，以及如何在<a href="https://www.linuxprobe.com/" target="_blank" rel="noopener">Linux系统</a>中添加、删除、修改用户账户信息。我们还可以使用SUID、SGID与SBIT特殊权限更加灵活地设置系统权限功能，来弥补对文件设置一般操作权限时所带来的不足。隐藏权限能够给系统增加一层隐形的防护层，让黑客最多只能查看关键日志信息，而不能进行修改或删除。而文件的访问控制列表（Access Control List，ACL）可以进一步让单一用户、用户组对单一文件或目录进行特殊的权限设置，让文件具有能满足工作需求的最小权限。本章最后还将讲解如何使用su<a href="https://www.linuxcool.com/" target="_blank" rel="noopener">命令</a>与sudo服务让普通用户具备管理员的权限，不仅可以满足日常的工作需求，还可以确保系统的安全性。</p>
</li>
<li><p>用户身份与能力 - 5.1</p>
<ul>
<li><p>RHEL 7 系统中的用户身份</p>
<ul>
<li><p><strong>管理员UID为 0</strong>: 系统的管理员用户</p>
</li>
<li><p><strong>系统用户UID为1~999</strong>: Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至正台服务器,<strong>默认服务程序会有独立的系统用户负责运行</strong>,进而有效的控制被破坏范围.</p>
</li>
<li><p><strong>普通用户UID从1000开始</strong>: 是由管理员创建的用于日常工作的用户</p>
</li>
<li><p><strong>创建每个用户时</strong>,都将<strong>自动创建</strong>一个与之同名的<strong>基本组</strong>,而这个基本用户组只有该用户一个人.如果该用户以后被纳入其他用户组,则这个其他用户组称之为<strong>扩展组</strong>.<strong>一个用户只有一个基本组,但可以有多个扩展用户组</strong>.</p>
</li>
<li><p><strong>注意:UID不能冲突,管理员创建的用户UID默认从1000开始,即时前面有闲置的号码</strong> </p>
</li>
<li><p><strong>用户组:</strong>为了方便管理属于同一组的用户,通过使用用户组号码<strong>GID</strong>(Group IDentification)可以把多个用户加入到同一组中,从而方便为组中的用户统一规划权限或指定任务</p>
<p>  假设有一个公司中有多个部门，每个部门中又有很多员工。如果只想让员工访问本部门内的资源，则可以针对部门而非具体的员工来设置权限。例如，可以通过对技术部门设置权限，使得只有技术部门的员工可以访问公司的数据库信息等。</p>
</li>
<li><p><strong>命令:</strong></p>
<ul>
<li><p>命令id 用户名:查询用户id和相关信息</p>
</li>
<li><p>查看所有用户: cat /etc/passwd</p>
</li>
<li><p>1.<strong>useradd命令</strong>:创建新的用户</p>
<ul>
<li><p><strong>格式为</strong>:useradd [选项] 用户名</p>
<ul>
<li><p><strong>命令参数</strong></p>
<ul>
<li><p><strong>-d</strong>:指定用户的家目录</p>
<ul>
<li>d = dir的意思</li>
</ul>
</li>
<li><p><strong>-e</strong>:账户的到期时间,格式为YYYY-MM-DD</p>
<ul>
<li>e = Expire date的意思</li>
</ul>
</li>
<li><p><strong>-u</strong>:指定该用户的默认UID</p>
<ul>
<li>u = UID的意思</li>
</ul>
</li>
<li><p><strong>-g</strong>:指定一个初始的用户基本组(必须已存在)</p>
<ul>
<li>g = group 的意思</li>
</ul>
</li>
<li><p><strong>-G</strong>:指定一个或多个扩展用户组</p>
<ul>
<li>G = Group的意思</li>
</ul>
</li>
<li><p><strong>-N</strong>:不创建与用户同名的基本用户组</p>
<ul>
<li>N = Not 的意思</li>
</ul>
</li>
<li><p><strong>-s</strong>:指定该用户的默认Shell解释器</p>
<ul>
<li>s = shell 的意思</li>
</ul>
</li>
<li><p><strong>例子:</strong>使用命令创建一个普通用户并指定家目录的路径\用户的UID以及Shell解释器(<strong>注意/sbin/nologin</strong>解释器与Bash有天壤之别/一旦用户的解释器被设置为nologin,则代表该用户不能登录到系统中</p>
<ul>
<li><p><strong>例子代码</strong></p>
<p>  [root@linuxprobe ~]# useradd -d /home/linux -u 8888 -s /sbin/nologin linuxprobe<br>  [root@linuxprobe ~]# id linuxprobe<br>  uid=8888(linuxprobe) gid=8888(linuxprobe) groups=8888(linuxprobe)</p>
</li>
<li><p><strong>目录/sbin/:放置的是系统管理员必备工具</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用该命令创建用户账户时,<strong>默认用户家目录会被存放在/home目录中</strong></p>
<ul>
<li><strong>默认的Shell解释器为/bin/bash</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.<strong>groupadd命令</strong>:创建用户组</p>
<ul>
<li><p><strong>格式为</strong>:groupadd [选项] 群组名</p>
<ul>
<li><p><strong>例子:</strong></p>
<p>  为了能够更加高效地指派系统中各个用户的权限，在工作中常常会把几个用户加入到同一个组里面，这样便可以针对一类用户统一安排权限。创建用户组的步骤非常简单，例如使用如下命令创建一个用户组ronny：</p>
<p>  [root@linuxprobe ~]# groupadd ronny</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>3.<strong>usermod命令</strong>:修改用户的属性</p>
<ul>
<li><p><strong>格式为</strong>:usermod [选项] 用户名</p>
<ul>
<li><p>命令参数</p>
<ul>
<li><p><strong>-c</strong>:填写用户的备注信息</p>
</li>
<li><p><strong>-d -m</strong>: 参数-m与参数-d连用,可重新指定用户的家目录并自动把旧的数据转移过去</p>
<ul>
<li>m=migrate , d=data 的意思</li>
</ul>
</li>
<li><p><strong>-e</strong>:账户的到期时间,格式为YYYY-MM-DD</p>
<ul>
<li>e = Expired 的意思</li>
</ul>
</li>
<li><p><strong>-g</strong>:变更所属用户组</p>
<ul>
<li>g = group的意思</li>
</ul>
</li>
<li><p><strong>-G</strong>:变更扩展用户组</p>
<ul>
<li>G = Group 的意思</li>
</ul>
</li>
<li><p><strong>-L</strong>:锁定用户禁止其登录</p>
<ul>
<li><strong>L</strong> = Locking 的意思</li>
</ul>
</li>
<li><p><strong>-U</strong>:解锁用户,允许其登录系统</p>
<ul>
<li><strong>U</strong> = Unlock 的意思</li>
</ul>
</li>
<li><p><strong>-s</strong>:变更默认终端</p>
<ul>
<li><strong>s</strong> = Shell的意思</li>
</ul>
</li>
<li><p><strong>-u</strong>:修改用户的UID</p>
<ul>
<li><strong>u</strong> = UID 的意思</li>
</ul>
</li>
</ul>
</li>
<li><p>例子</p>
<p>  大家不要被这么多参数吓坏了。我们先来看一下账户linuxprobe的默认信息：<br>  [root@linuxprobe ~]# id linuxprobe<br>  uid=1000(linuxprobe) gid=1000(linuxprobe) groups=1000(linuxprobe)<br>  然后将用户linuxprobe加入到root用户组中，这样扩展组列表中则会出现root用户组的字样，而基本组不会受到影响：<br>  [root@linuxprobe ~]# usermod -G root linuxprobe<br>  [root@linuxprobe ~]# id linuxprobe<br>  uid=1000(linuxprobe) gid=1000(linuxprobe) groups=1000(linuxprobe),0(root)<br>  再来试试用-u参数修改linuxprobe用户的UID号码值。除此之外，我们还可以用-g参数修改用户的基本组ID，用-G参数修改用户扩展组ID。<br>  [root@linuxprobe ~]# usermod -u 8888 linuxprobe<br>  [root@linuxprobe ~]# id linuxprobe<br>  uid=8888(linuxprobe) gid=1000(linuxprobe) groups=1000(linuxprobe),0(root)</p>
<ul>
<li>使用命令 <strong>[id] [用户名]</strong> 查询指定要用户的信息</li>
</ul>
</li>
<li><p>Linux一切皆文,因此在系统中创建用户也是修改配置文件的过程.<strong>用户的信息保存在/etc/passwd文件中</strong>,可以直接用文本编辑器修改其中的用户参数项目,也可以用usermod命令修改已经创建的用户信息</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>4.passwd命令:修改用户密码</p>
<p>  passwd命令用于修改用户密码\过期时间\认证信息等</p>
<ul>
<li><p>格式为:passwd[选项]用户名</p>
<ul>
<li><p>命令参数</p>
<ul>
<li><p>-l:锁定用户,禁止其登录</p>
<ul>
<li>l= Locking 的意思</li>
</ul>
</li>
<li><p>-u:解除锁定,允许用户登录</p>
<ul>
<li>u = Unlock 的意思</li>
</ul>
</li>
<li><p>—stdin:允许用户通过标准输入修改用户密码,如echo “NewPassWord” | passwd —stdin Username</p>
<ul>
<li>stdin = Standard Input 的意思</li>
</ul>
</li>
<li><p>-d:使该用户可用空密码登录系统</p>
<ul>
<li>-d=Don’t Password?</li>
</ul>
</li>
<li><p>-e:强制用户在下次登录时修改密码</p>
</li>
<li><p>-S:显示用户密码是否被锁定,以及密码所采用的加密算法名称</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>root与普通用户在修改密码上的区别</p>
<ul>
<li><p>普通用户只能用passwd命令修改自身的密码</p>
</li>
<li><p>root用户可以修改所有用户的密码,而且不需要验证旧密码</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>5.userdel命令:删除用户</p>
<ul>
<li><p>格式为:userdel [选项] 用户名</p>
<ul>
<li><p>命令参数</p>
<ul>
<li><p>-f:强制删除用户</p>
</li>
<li><p>-r:同时删除用户及家目录</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>文件权限与归属 -5.2</p>
<p>  尽管在Linux系统中一切都是文件，但是每个文件的类型不尽相同，因此Linux系统使用了不同的字符来加以区分，常见的字符如下所示。</p>
<ul>
<li><p>文件的权限</p>
<ul>
<li><p><strong>可读(r):</strong>表示能够读取文件的实际内容</p>
<ul>
<li>数字表示为:4</li>
</ul>
</li>
<li><p><strong>可写(w):</strong>表示能够编辑\新增\修改\删除文件的实际内容</p>
<ul>
<li>数字表示为:2</li>
</ul>
</li>
<li><p><strong>可执行(x):</strong>表示能够运行一个脚本程序</p>
<ul>
<li>数字表示为:1</li>
</ul>
</li>
<li><p>文件所有者\文件所有组\其他用户:这些<strong>权限之间无关联</strong></p>
</li>
</ul>
</li>
<li><p>目录的权限</p>
<ul>
<li><p><strong>可读:</strong>表示能够读取目录内的文件列表</p>
</li>
<li><p><strong>可写:</strong>表示能在目录内新增\删除\重命名文件</p>
</li>
<li><p><strong>可执行:</strong>表示能够进入该目录</p>
</li>
</ul>
</li>
<li><p>字符区分文件类型</p>
<ul>
<li><p>-:普通文件</p>
</li>
<li><p>d:目录文件</p>
</li>
<li><p>l:链接文件</p>
</li>
<li><p>b:块设备文件</p>
</li>
<li><p>c:字符设备文件</p>
</li>
<li><p>p:管道文件</p>
</li>
</ul>
</li>
<li><p>图片:文字权限的字符与数字表示</p>
<p>  <a href="https://www.linuxprobe.com/wp-content/uploads/2015/02/%E6%9D%83%E9%99%90%E5%80%BC.png" target="_blank" rel="noopener">https://www.linuxprobe.com/wp-content/uploads/2015/02/%E6%9D%83%E9%99%90%E5%80%BC.png</a></p>
<ul>
<li><p>文件权限的数字法基于字符表示(rwx)的权限计算而来,其目的是简化权限的表示</p>
<ul>
<li><p>例如某个文件:</p>
<ul>
<li><p>某权限为7代表:可读\可写\可执行 (4+2+1)</p>
</li>
<li><p>权限为6则代表:可读\可写(4+2)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>三者间没有互通的关系</p>
</li>
<li><p>通过ls命令查到的文件属性信息</p>
<ul>
<li><p>解释</p>
<p>  在图5-1中，包含了文件的类型、访问权限、所有者（属主）、所属组（属组）、占用的磁盘大小、修改时间和文件名称等信息。通过分析可知，该文件的类型为普通文件，所有者权限为可读、可写（rw-），所属组权限为可读（r–），除此以外的其他人也只有可读权限（r–），文件的磁盘占用大小是34298字节，最近一次的修改时间为4月2日的凌晨23分，文件的名称为install.log。</p>
</li>
</ul>
</li>
<li><p>练习:</p>
<ul>
<li><p>字符与数字表示互相转化</p>
<p>  1.计算764\642\153\731数字表示法对应的字符表示法  </p>
<p>  764:rwxrw-r—<br>  642:rw-r—-w-<br>  157:—xr-xrwx<br>  731:rwx-wx—x  </p>
<p>  2.把rwxrw-r—\rw—w—wx\rw-r—r—转换成数字表示法  </p>
<p>  rwxrw-r—:764<br>  rw—w—wx:623<br>  rw-r—r—:644</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>文件的特殊权限 -5.3</p>
<p>  在复杂多变的生产环境中,单纯设置文件的rwx权限无法满足我们对安全性和灵活性的需求,因此便有了SUID\SGID\SBIT的特殊权限位  </p>
<p>  这是一对文件权限设置的特殊功能,可以与一般权限同时使用,以弥补一般权限不能实现的功能</p>
<ul>
<li><p>1.SUID</p>
<p>  一种对二进制程序设置的特殊权限,可以让二进制程序的执行者临时拥有属主的权限(仅对拥有执行权限的二进制程序有效)</p>
<ul>
<li><p>例如</p>
<p>  用户密码保存在/etc/shadow文件中,它的权限是000(只有root管理员可以查看和编辑)  </p>
<p>  但是,在使用passwd命令时如果加上SUID特殊权限位,就可让普通用户历史获得程序所有者的身份,把变更的密码信息写入到shadow文件中.  </p>
<p>  这很像我们在古装剧中见到的手持尚方宝剑的钦差大臣，他手持的尚方宝剑代表的是皇上的权威，因此可以惩戒贪官，但这并不意味着他永久成为了皇上。因此这只是一种有条件的、临时的特殊权限授权方法。</p>
</li>
<li><p>查看命令属性时发现所有者权限有<strong>rwx变成了rws</strong>,其中<strong>x变成s</strong>就意味着该文件被赋予了<strong>SUID权限</strong>,如果原本权限是rw-没有x权限,那么特选权限被赋予后就会变成大写的S</p>
<ul>
<li><p>例子</p>
<p>  [root@linuxprobe ~]# ls -l /etc/shadow<br>  ———-. 1 root root 1004 Jan 3 06:23 /etc/shadow<br>  [root@linuxprobe ~]# ls -l /bin/passwd<br>  -rwsr-xr-x. 1 root root 27832 Jan 29 2017 /bin/passwd</p>
</li>
</ul>
</li>
<li><p><strong>一种对二进制程序设置的特殊权限</strong>,可以让二进制程序的执行者临时拥有属主的权限(<strong>仅对拥有执行权限的二进制程序有效</strong>)</p>
<ul>
<li><strong>取得的是文件所有者的权限</strong></li>
</ul>
</li>
<li><p>总结:让二进制程序可以访问目录的权限</p>
</li>
</ul>
</li>
<li><p>2.SGID</p>
<ul>
<li><p>主要实现一下两种功能</p>
<ul>
<li><p>1.让<strong>执行者临时</strong>拥有<strong>属主权限</strong>(对拥有执行权限的<strong>二进制程序进行设置</strong>)</p>
<p>  <strong>SGID的第一种功能是参考SUID而设计的</strong>，不同点在于执行程序的用户获取的不再是文件所有者的临时权限，<strong>而是获取到文件所属组的权限</strong>。举例来说，在早期的Linux系统中，/dev/kmem是一个字符设备文件，用于存储内核程序要访问的数据，权限为：<br>  <strong>cr–r—–</strong>   1 root system 2,  1 Feb 11 2017  kmem</p>
<p>  大家看出问题了吗？除了root管理员或属于system组成员外，所有用户都没有读取该文件的权限。由于在平时我们需要查看系统的进程状态，为了能够获取到进程的状态信息，可在用于查看系统进程状态的ps命令文件上增加SGID特殊权限位。查看ps命令文件的属性信息：<br>  -r-xr-<strong>s</strong>r-x   1 bin system 59346 Feb 11 2017  ps<br>  这样一来，由于ps命令被增加了SGID特殊权限位，所以当用户执行该命令时，也就临时获取到了system用户组的权限，从而可以顺利地读取设备文件了。</p>
<ul>
<li><p><strong>取得的是文件所属组的权限</strong></p>
</li>
<li><p><strong>SGID的第一种功能是参考SUID而设计的</strong>，不同点在于执行程序的用户获取的不再是文件所有者的临时权限，<strong>而是获取到文件所属组的权限</strong></p>
<ul>
<li><strong>比如：</strong>让普通用户临时拥有用ps命令查看系统进程的权利，就需要设置ps文件为SUID权限位</li>
</ul>
</li>
</ul>
</li>
<li><p>2.在某个目录中创建的文件自动继承该目录的用户组(只可对目录进行设置)</p>
<ul>
<li><p>例如</p>
<p>  如果现在需要在一个部门内设置共享目录，让部门内的所有人员都能够读取目录中的内容，那么就可以创建部门共享目录后，在该目录上设置SGID特殊权限位。这样，部门内的任何人员在里面创建的任何文件都会归属于该目录的所属组，而不再是自己的基本用户组。此时，我们用到的就是SGID的第二个功能，即在某个目录中创建的文件自动继承该目录的用户组（只可以对目录进行设置）。</p>
<ul>
<li><p>命令集</p>
<p>  [root@linuxprobe ~]# cd /tmp<br>  [root@linuxprobe tmp]# mkdir testdir<br>  [root@linuxprobe tmp]# ls -ald testdir/<br>  drwxr-xr-x. 2 root root 6 Feb 11 11:50 testdir/<br>  [root@linuxprobe tmp]# chmod -Rf 777 testdir/<br>  [root@linuxprobe tmp]# chmod -Rf g+s testdir/<br>  [root@linuxprobe tmp]# ls -ald testdir/<br>  drwxrwsrwx. 2 root root 6 Feb 11 11:50 testdir/</p>
<ul>
<li><p>切换普通用户试试创建文件是否会继承所在目的的所属组名称</p>
<p>  在使用上述命令设置好目录的777权限（确保普通用户可以向其中写入文件），并为该目录设置了SGID特殊权限位后，就可以切换至一个普通用户，然后尝试在该目录中创建文件，并查看新创建的文件是否会继承新创建的文件所在的目录的所属组名称：</p>
<ul>
<li><p>命令集</p>
<p>  [root@linuxprobe tmp]# su - linuxprobe<br>  Last login: Wed Feb 11 11:49:16 CST 2017 on pts/0<br>  [linuxprobe@linuxprobe ~]$ cd /tmp/testdir/<br>  [linuxprobe@linuxprobe testdir]$ echo “linuxprobe.com” &gt; test<br>  [linuxprobe@linuxprobe testdir]$ ls -al test<br>  -rw-rw-r–. 1 linuxprobe root 15 Feb 11 11:50 test</p>
</li>
</ul>
</li>
<li><p>切换到SUID权限位后<strong>x</strong>会变成<strong>s</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>再次提示:每个<strong>文件</strong>都有其归属的<strong>所有者</strong>和<strong>所属组</strong>，当创建或传送一个文件后，这个文件就会<strong>自动归属</strong>于执行这个操作的用户（即该用户是文件的所有者）</p>
</li>
<li><p>使用命令: <strong>chmod -Rf g+s 目录名</strong> 设置SGID</p>
</li>
<li><p>总结:设置二进制程序访问目录的权限,也同时作用于文件</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>3.SBIT(Sticky Bit 粘滞位\保护位)</p>
<ul>
<li><p>RHEL 7 的/tmp共享目录就默认是SBIT特殊权限位</p>
</li>
<li><p>当某个目录设置为SBIT权限位后,该目录中的文件就只能被其所有者执行删除了</p>
<ul>
<li></li>
</ul>
</li>
<li><p>当目录被设置为SBIT特殊权限位后,文件的其他人权限部分的x执行权限就会被替换成t或者T,原本有x执行权限则会写成t，原本没有x执行权限则会被写成T</p>
<ul>
<li><p>命令实例</p>
<p>  [root@linuxprobe tmp]# su - linuxprobe<br>  Last login: Wed Feb 11 12:41:20 CST 2017 on pts/0<br>  [linuxprobe@linuxprobe tmp]$ ls -ald /tmp<br>  drwxrwxrwt. 17 root root 4096 Feb 11 13:03 /tmp<br>  [linuxprobe@linuxprobe ~]$ cd /tmp<br>  [linuxprobe@linuxprobe tmp]$ ls -ald<br>  drwxrwxrwt. 17 root root 4096 Feb 11 13:03 .<br>  [linuxprobe@linuxprobe tmp]$ echo “Welcome to linuxprobe.com” &gt; test<br>  [linuxprobe@linuxprobe tmp]$ chmod 777 test<br>  [linuxprobe@linuxprobe tmp]$ ls -al test<br>  -rwxrwxrwx. 1 linuxprobe linuxprobe 10 Feb 11 12:59 test</p>
<ul>
<li>修改SBIT后权限有x会变成t,没x会变成T</li>
</ul>
</li>
</ul>
</li>
<li><p>文件能否被删除并不取决于自身的权限,而是看其所在目录是否有写入权限</p>
</li>
<li><p>使用命令:<strong>chmod -R o+t 目录名</strong> 设置SBIT</p>
</li>
<li><p>总结:只有创建(所有者)能删除,你创建的你自己可以删,但是别人创建的你就休想删除了!!</p>
</li>
</ul>
</li>
<li><p>4.设置权限的两个命令</p>
<ul>
<li><p>chmod:设置文件和目录的权限</p>
<ul>
<li><p>chmod命令格式:chmod [参数] 权限 文件或目录名</p>
<ul>
<li><p>参数</p>
<ul>
<li><p>u+s参数:设置SUID特殊权限位</p>
</li>
<li><p>-Rf g+s参数:设置SGID特殊权限位</p>
</li>
<li><p>-R o+t参数:设置SBIT特殊权限位</p>
</li>
</ul>
</li>
<li><p>例子</p>
<p>  把一个文件的权限设置成其所有者可读可写可执行、所属组可读可写、其他人没有任何权限，则相应的字符法表示为rwxrw—-，其对应的数字法表示为760。通过前面的基础学习和当前的练习实践，现在大家可以感受到使用数字法来设置文件权限的便捷性了吧</p>
<ul>
<li><p>命令示例</p>
<p>  [root@linuxprobe ~]# ls -al test<br>  -rw-rw-r–. 1 linuxprobe root 15 Feb 11 11:50 test<br>  [root@linuxprobe ~]# chmod 760 test<br>  [root@linuxprobe ~]# ls -l test<br>  -rwxrw—-. 1 linuxprobe root 15 Feb 11 11:50 test</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>chown:设置所有者和所属组</p>
<ul>
<li>chown命令格式:chown [参数] 所有者:所属组 文件或目录名称</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>文件的隐藏权限 -5.4</p>
<ul>
<li><p>1.chattr命令：用于设置文件隐藏权限(attr是属性的简写)</p>
<ul>
<li><p>格式为：chattr [参数] 文件</p>
<ul>
<li><p>参数</p>
<ul>
<li><p>A:不在修改这个文件或目录的最后访问时间</p>
<ul>
<li>atime</li>
</ul>
</li>
<li><p><strong>a:仅允许补充(追加)内容,无法覆盖删除内容</strong></p>
<ul>
<li>Append Only</li>
</ul>
</li>
<li><p>b:不在修改文件或目录的存取时间</p>
</li>
<li><p>c:默认将文件或目录进行压缩</p>
</li>
<li><p>D:检查压缩文件中的错误</p>
</li>
<li><p>d:使用dump命令备份时忽略本文件/目录</p>
</li>
<li><p><strong>i:无法对文件进行修改;若对目录设置了此参数,则只能修改其中的子文件内容而不能新建或删除文件</strong></p>
</li>
<li><p><strong>S:文件内容在变更后立即同步到硬盘</strong></p>
<ul>
<li>Sync</li>
</ul>
</li>
<li><p>s:彻底从硬盘中删除,不可恢复(用0填充原文件所在硬盘区域)</p>
</li>
<li><p><strong>u:当删除该文件后依然保留其在硬盘中的数据,方便日后恢复</strong></p>
</li>
<li><p>t:让文件系统支持尾部合并</p>
<ul>
<li>tail-merging</li>
</ul>
</li>
<li><p>x:可以直接访问压缩文件中的内容</p>
</li>
</ul>
</li>
<li><p>给文件添加隐藏功能需要添加:”+” 和”参数”</p>
</li>
<li><p>把某个隐藏文件移除文件需要添加:”-“和“参数”</p>
</li>
<li><p>例子</p>
<p>  添加前可以删除  </p>
<p>  [root@linuxprobe ~]# echo “for Test” &gt; linuxprobe<br>  [root@linuxprobe ~]# rm linuxprobe<br>  rm: remove regular file ‘linuxprobe’? y  </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>            添加隐藏权限后不能删除:

            [root@linuxprobe ~]# echo &quot;for Test&quot; &gt; linuxprobe  
            [root@linuxprobe ~]# chattr +a linuxprobe  
            [root@linuxprobe ~]# rm linuxprobe  
            rm: remove regular file ‘linuxprobe’? y  
            rm: cannot remove ‘linuxprobe’: Operation not permitted

- 2.lsattr命令:显示文件的隐藏权限(ls是列出目录和文件的命令,attr是属性的简写)

    - 格式为:lsattr [参数] 文件

        在Linux系统中文件的隐藏权限必须使用lsattr命令来查看,使用ls命令看不出端倪

        - 例子

            使用ls看不出端倪

            [root@linuxprobe ~]# ls -al linuxprobe  
            -rw-r--r--. 1 root root 9 Feb 12 11:42 linuxprobe  


            使用lsattr才可看出来

            [root@linuxprobe ~]# lsattr linuxprobe  
            -----a---------- linuxprobe  
            [root@linuxprobe ~]# chattr -a linuxprobe  
            [root@linuxprobe ~]# lsattr linuxprobe   
            ---------------- linuxprobe  
            [root@linuxprobe ~]# rm linuxprobe   
            rm: remove regular file ‘linuxprobe’? y</code></pre><ul>
<li><p>文件的访问控制列表 5.5</p>
<p>  不知道大家是否发现，前文讲解的一般权限、特殊权限、隐藏权限其实有一个共性—权限是针对某一类用户设置的。如果希望对某个指定的用户进行单独的权限控制，就需要用到文件的访问控制列表（ACL）了。通俗来讲，基于普通文件或目录设置ACL其实就是针对指定的用户或用户组设置文件或目录的操作权限。另外，如果针对某个目录设置了ACL，则目录中的文件会继承其ACL；若针对文件设置了ACL，则文件不再继承其所在目录的ACL。</p>
<ul>
<li><p>1.setfacl命令:设置ACL</p>
<p>  分解:<br>  set 设置<br>  f 文件<br>  acl 文件访问控制列表</p>
<ul>
<li><p>格式为:setfacl [参数] 文件名称</p>
<p>  ACL文件访问控制列表</p>
<p>  文件的ACL提供的是在所有者\所属组\其他人的读\写\执行权限之外的特殊权限控制,使用setfacl命令可以针对单一用户或用户组、单一文件或目录来进行读/写/执行权限的控制。其中，针对目录文件需要使用-R递归参数；针对普通文件则使用-m参数；如果想要删除某个文件的ACL，则可以使用-b参数。下面来设置用户在/root目录上的权限：</p>
<ul>
<li><p>-R:针对目录文件使用的递归参数</p>
</li>
<li><p>-m:针对普通文件使用的参数</p>
</li>
<li><p>-b:删除某个文件的ACL</p>
</li>
<li><p>例子:setfacl -Rm u:linuxprobe:rwx /root</p>
<ul>
<li><p>设置用户还是组</p>
<ul>
<li><p>“u:用户名:权限”</p>
</li>
<li><p>“g:用户组:权限”</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>查看是否有ACL权限:ls -ald 查看文件权限会发现文件权限最后的一个”<strong>.</strong>”变成了”<strong>+</strong>”就意味着该文件已经设置了ACL了</p>
</li>
<li><p>例子</p>
<p>  [root@linuxprobe ~]# setfacl -Rm u:linuxprobe:rwx /root<br>  [root@linuxprobe ~]# su - linuxprobe<br>  Last login: Sat Mar 21 15:45:03 CST 2017 on pts/1<br>  [linuxprobe@linuxprobe ~]$ cd /root<br>  [linuxprobe@linuxprobe root]$ ls<br>  anaconda-ks.cfg Downloads Pictures Public<br>  [linuxprobe@linuxprobe root]$ cat anaconda-ks.cfg<br>  [linuxprobe@linuxprobe root]$ exit</p>
</li>
</ul>
</li>
<li></li>
</ul>
</li>
<li><p>2.getfacl命令:显示ACL</p>
<p>  getfacl命令用于显示文件上设置的ACL信息</p>
<ul>
<li><p>格式为:getfacl 文件名称</p>
<ul>
<li><p>例子</p>
<p>  [root@linuxprobe ~]# getfacl /root<br>  getfacl: Removing leading ‘/‘ from absolute path names  </p>
<h1 id="file-root"><a href="#file-root" class="headerlink" title="file: root"></a>file: root</h1><h1 id="owner-root"><a href="#owner-root" class="headerlink" title="owner: root"></a>owner: root</h1><h1 id="group-root"><a href="#group-root" class="headerlink" title="group: root"></a>group: root</h1><p>  user::r-x<br>  user:linuxprobe:rwx<br>  group::r-x<br>  mask::rwx<br>  other::—</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>关键词</p>
<ul>
<li><p>ACL(Access Control List)</p>
<p>  ACL文件访问控制列表</p>
<p>  文件的ACL提供的是在所有者\所属组\其他人的读\写\执行权限之外的特殊权限控制,</p>
</li>
</ul>
</li>
<li><p>总结:就是针对指定用户设置操作权限</p>
</li>
</ul>
</li>
<li><p>su命令 与 sudo服务</p>
<ul>
<li><p>su命令</p>
<p>  su命令可以解决切换用户身份的需求,使当前用户在不退出登录的情况下,顺畅的切换到其他用户,比如从root管理员切换到普通用户</p>
<ul>
<li><p>例子:su切换用户</p>
<p>  [root@linuxprobe ~]# id<br>  uid=0(root) gid=0(root) groups=0(root)<br>  [root@linuxprobe ~]# su - linuxprobe<br>  Last login: Wed Jan 4 01:17:25 EST 2017 on pts/0<br>  [linuxprobe@linuxprobe ~]$ id<br>  uid=1000(linuxprobe) gid=1000(linuxprobe) groups=1000(linuxprobe) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</p>
<ul>
<li>“-“的意思是:完全切换到新用户(即把环境变量信息也变更为新用户的相应信息,而不是保留原始的信息),强烈建议切换身份时添加这个”-“</li>
</ul>
</li>
<li><p>例子2:切回root需要密码验证</p>
<p>  [linuxprobe@linuxprobe root]$ su root<br>  Password:<br>  [root@linuxprobe ~]# su - linuxprobe<br>  Last login: Mon Aug 24 19:27:09 CST 2017 on pts/0<br>  [linuxprobe@linuxprobe ~]$ exit<br>  logout<br>  [root@linuxprobe ~]#  </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>        当从root管理员切换到普通用户时是不需要密码验证的，而从普通用户切换成root管理员就需要进行密码验证了

        尽管像上面这样使用su命令后，普通用户可以完全切换到root管理员身份来完成相应工作，但这将暴露root管理员的密码，从而增大了系统密码被黑客获取的几率；这并不是最安全的方案。
        刘遄老师接下来将介绍如何使用sudo命令把特定命令的执行权限赋予给指定用户，这样既可保证普通用户能够完成特定的工作，也可以避免泄露root管理员密码。我们要做的就是合理配置sudo服务，以便兼顾系统的安全性和用户的便捷性。sudo服务的配置原则也很简单—在保证普通用户完成相应工作的前提下，尽可能少地赋予额外的权限。

- sudo服务

    - sudo命令:给普通用户额外root权限

        - 格式为:sudo [参数] 命令名称

            - sudo命令的参数

                - -h:显示帮助信息

                - -l:列出当前用户可执行的命令

                - -u 用户名/UID值:以指定的用户身份执行命令

                - -k:清空密码的有效时间,下次执行sudo时需要再次密码验证

                - -b:在后台执行指定的命令

                - -p:更改询问密码的提示语

            - 总结sudo的命令具有以下功能

                - 限制用户执行指定的命令

                - 记录用户执行的每一条命令

                - 配置文件(/etc/sudoers)提供集中的用户管理\权限与主机等参数

                    - 担心直接修改会出现问题,可以用sudo命令的**visudo**命令来配置用户权限.这条命令在配置用户权限时将禁止多个用户同时修改sudoers配置文件,还可以对配置文件内的参数进行语法检查(**只有root管理员才可以使用visudo命令编辑sudo服务的配置文件**)

                - 验证密码后的5分钟内(默认值)无需再让用户再次验证密码

            - visudo命令

                担心直接修改会出现问题,可以用sudo命令的**visudo**命令来配置用户权限.这条命令在配置用户权限时将禁止多个用户同时修改sudoers配置文件,还可以对配置文件内的参数进行语法检查(**只有root管理员才可以使用visudo命令编辑sudo服务的配置文件**)

                - 找到99行左右(vim中使用”:set nu”显示行号)

                    - 例子:修改权限

                        [root@linuxprobe ~]# visudo  
                         96 ##  
                         97 ## Allow root to run any commands anywhere  
                         98 root ALL=(ALL) ALL  
                         99 linuxprobe ALL=(ALL) ALL

                        - linuxprobe ALL=(ALL) ALL “**谁可以使用  允许使用的主机=（以谁的身份）  可执行命令的列表”**

                        - 保存

                        - 再次修改:修改为只能执行特定的root命令

                            - 例子

                                [linuxprobe@linuxprobe ~]$ exit  
                                logout  
                                [root@linuxprobe ~]# whereis cat  
                                cat: /usr/bin/cat /usr/share/man/man1/cat.1.gz /usr/share/man/man1p/cat.1p.gz  
                                [root@linuxprobe ~]# visudo  
                                 96 ##  
                                 97 ## Allow root to run any commands anywhere  
                                 98 root ALL=(ALL) ALL  
                                 99 linuxprobe ALL=(ALL) /usr/bin/cat

                                - 如果需要让某个用户只能使用root管理员的身份执行指定的命令，**切记一定要给出该命令的绝对路径**，否则系统会识别不出来。我们可以先使用**whereis**命令找出命令所**对应的保存路径**，然后把配置文件第99行的用户权限参数修改成对应的路径即可

                                    - 保存后

                        - 不用验证密码的方法:添加NOPASSWD参数

                            - 例子

                                [linuxprobe@linuxprobe ~]$ exit  
                                logout  
                                [root@linuxprobe ~]# whereis poweroff  
                                poweroff: /usr/sbin/poweroff /usr/share/man/man8/poweroff.8.gz  
                                [root@linuxprobe ~]# visudo  
                                 96 ##  
                                 97 ## Allow root to run any commands anywhere  
                                 98 root ALL=(ALL) ALL  
                                 99 linuxprobe ALL=NOPASSWD: /usr/sbin/poweroff

                                - 用命令whereis poweroff:找到poweroff的文件位置

                                - 修改  
                                  linuxprobe ALL=(ALL) ALL  
                                  为  
                                  linuxprobe ALL=NOPASSWD: /usr/sbin/poweroff

                - 切换到这个普通用户就可以使用sudo命令流

                    - 例子:切换到普通用户使用sudo -l 查看可执行的命令

                        [root@linuxprobe ~]# su - linuxprobe  
                        Last login: Thu Sep 3 15:12:57 CST 2017 on pts/1  
                        [linuxprobe@linuxprobe ~]$ sudo -l  
                        [sudo] password for linuxprobe:此处输入linuxprobe用户的密码
                        Matching Defaults entries for linuxprobe on this host:  
                        requiretty, !visiblepw, always_set_home, env_reset, env_keep=&quot;COLORS  
                        DISPLAY HOSTNAME HISTSIZE INPUTRC KDEDIR LS_COLORS&quot;, env_keep+=&quot;MAIL PS1  
                        PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE&quot;, env_keep+=&quot;LC_COLLATE  
                        LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES&quot;, env_keep+=&quot;LC_MONETARY  
                        LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE&quot;, env_keep+=&quot;LC_TIME LC_ALL  
                        LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY&quot;,  
                        secure_path=/sbin\:/bin\:/usr/sbin\:/usr/bin  
                        User linuxprobe may run the following commands on this host:  
                        (ALL) ALL

                        - 注意:在使用时输入的密码是该用户的密码,不是root的密码

                    - 例子2:普通用户使用 ls /root 也可以了

                    - 例子3:不用验证密码</code></pre><h3 id="第六章储存结构与磁盘划分"><a href="#第六章储存结构与磁盘划分" class="headerlink" title="第六章储存结构与磁盘划分"></a>第六章储存结构与磁盘划分</h3><p>目录:</p>
<pre><code>[6.1 一切从“/”开始](https://www.linuxprobe.com/chapter-06.html#61)
[6.2 物理设备的命名规则](https://www.linuxprobe.com/chapter-06.html#62)
[6.3 文件系统与数据资料](https://www.linuxprobe.com/chapter-06.html#63)
[6.4 挂载硬件设备](https://www.linuxprobe.com/chapter-06.html#64)
[6.5 添加硬盘设备](https://www.linuxprobe.com/chapter-06.html#65)
[6.6 添加交换分区](https://www.linuxprobe.com/chapter-06.html#66)
[6.7 磁盘容量配额](https://www.linuxprobe.com/chapter-06.html#67)
[6.8 软硬方式链接](https://www.linuxprobe.com/chapter-06.html#68)</code></pre><p>本章将从Linux系统中的文件存储结构开始，讲述<strong>文件系统层次化标准（FHS，Filesystem Hierarchy Standard）</strong>、<strong>udev硬件命名规则</strong>以及<strong>硬盘分区的规划方法</strong>。</p>
<p>将在本章中详细地分析Linux系统中最常见的<strong>Ext3、Ext4与XFS文件系统的不同之处</strong>，并带领各位读者着重<strong>练习硬盘设备分区</strong>、<strong>格式化以及挂载等常用的硬盘管理操作</strong>，以便熟练掌握文件系统的使用方法。</p>
<p>在打下坚实的理论基础与完成一些相关的实践练习后，我们将进一步<strong>完整地部署SWAP交换分区、配置quota磁盘配额服务，以及掌握ln</strong><a href="https://www.linuxcool.com/" target="_blank" rel="noopener"><strong>命令</strong></a><strong>带来的软硬链接</strong>。相信各位读者在学习完本章后，会对Linux系统以及Windows系统中的磁盘存储以及文件系统有深入的理解。</p>
<ul>
<li><p>一切从”/“开始 -6.1</p>
<p>  在Linux系统中,目录\字符设备\块设备\套接字\打印机等都被抽象成了文件,即在Linux中一切皆是文件</p>
<ul>
<li><p>一切从/开始,并按照文件系统层次化标准(FHS)采用属性结构来存放文件,以及定义了常见的目录用途,<strong>并且文件名中不得包含/</strong></p>
<ul>
<li><p>Linux系统文件存储结构图</p>
<ul>
<li><p>目录名称以及存放内容</p>
<ul>
<li><p><strong>/boot</strong> : 开机所需文件-内核\开机菜单以及所需配置文件等</p>
</li>
<li><p><strong>/dev : 以文件形式存放任何设备与接口</strong></p>
<ul>
<li><strong>英文:Devices(设备)</strong></li>
</ul>
</li>
<li><p>/etc : 配置文件</p>
<ul>
<li>英文:Etcetera(等等)</li>
</ul>
</li>
<li><p>/home : 用户主目录</p>
</li>
<li><p>/bin : 存放单用户模式下还可以操作的命令</p>
<ul>
<li><p>英文: Binaries(二进制文件)</p>
</li>
<li><p>其实就是”命令库”</p>
</li>
</ul>
</li>
<li><p>/lib : 开机时用到的函数库,以及/bin与/sbin下面的命令要调用的函数</p>
<ul>
<li><p>英文:Libraries(图书馆)</p>
</li>
<li><p>程序的共享”函数库文件”目录</p>
</li>
</ul>
</li>
<li><p>/sbin : 开机过程中需要的命令</p>
<ul>
<li>英文:System-only binaries(仅系统二进制文件)</li>
</ul>
</li>
<li><p>/media : 用于挂在设备文件的目录</p>
</li>
<li><p>/opt : 放置第三方的软件</p>
<ul>
<li>英文 : Optionally(可选的)</li>
</ul>
</li>
<li><p>/root : 系统管理员的家目录</p>
</li>
<li><p>/srv : 一些网络服务的数据文件目录</p>
<ul>
<li>英文 : Service</li>
</ul>
</li>
<li><p>/tmp : 任何人均可使用的”共享”临时目录</p>
<ul>
<li>英文:Temporary files(临时文件)</li>
</ul>
</li>
<li><p>/proc : 虚拟文件系统,例如:系统内核\进程\外部设备\网络状态等</p>
<ul>
<li><p>英文 : Processes(流程)</p>
</li>
<li><p>虚拟文件系统:数据都在内存中</p>
</li>
</ul>
</li>
<li><p>usr(英文 : Unix Software Resource)通过系统自行安装的软件目录</p>
<ul>
<li><p>/usr/local : 用户自行安装的软件</p>
</li>
<li><p>/usr/sbin : Linux系统开机时不会使用到的软件/命令/脚本</p>
</li>
<li><p>/usr/share : 帮助与说明文件,也可以放置共享文件</p>
</li>
</ul>
</li>
<li><p>/var : 主要存放经常变化的文件,如日志</p>
<ul>
<li>英文:Variable files(可变文件)</li>
</ul>
</li>
<li><p>/lost+found : 当文件系统发生错误时,将一些丢失的文件片段存放在这里 </p>
</li>
<li><p>补充参考文章</p>
<ul>
<li><p>参考1</p>
<p>  <a href="https://blog.csdn.net/u012107143/article/details/54973028" target="_blank" rel="noopener">https://blog.csdn.net/u012107143/article/details/54973028</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>绝对路径和相对路径</p>
<ul>
<li><p>绝对路径(absolute path):从根目录/开始写起的文件或目录名称</p>
</li>
<li><p>相对路径(relative path) : 相对于当前路径的写法</p>
</li>
<li><p><strong>绝对与相对路径的形象描述:</strong></p>
<p>  这两种方法都正确。如果您说的是绝对路径，那么任何一位外国游客都可以按照这个提示找到潘家园的洗手间，但是太繁琐了。如果您说的是相对路径，虽然表达很简练，但是这位外国游客只能从当前位置（不见得是潘家园）出发找到洗手间，因此并不能保证在前面的路口左转后可以找到洗手间，由此可见，相对路径不具备普适性。</p>
<ul>
<li><p><strong>绝对路径（absolute path）:首先坐飞机来到中国，到了北京出首都机场坐机场快轨到三元桥，然后换乘10号线到潘家园站，出站后坐34路公交车到农光里，下车后路口左转。</strong></p>
</li>
<li><p><strong>相对路径（relative path）:前面路口左转。</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>物理设备的命名规则与硬盘分区 6.2</p>
<ul>
<li><p>系统内核中的udev设备管理器会自动把硬件名称规范起来</p>
<ul>
<li><p>常见硬件设备以及文件名称</p>
<ul>
<li><p>IDE设备 : /dev/hd[a-d]</p>
</li>
<li><p>SCSI/SATA/U盘:/dev/sd[a-p]</p>
<ul>
<li><p>a~p代表16块不同的硬盘(默认从a开始分配)</p>
<ul>
<li><p>分区编号的讲究</p>
<ul>
<li><p>主分区或扩展分区的编号从1开始到4结束</p>
</li>
<li><p>逻辑分区编号从5开始</p>
</li>
<li><p>误区</p>
<ul>
<li><p>1.sda中的a不是由<strong>插槽</strong>决定的,而是由系统内核<strong>识别的顺</strong>序来决定的</p>
</li>
<li><p>2.sda3中分区编号不是强制顺延的,也<strong>可以手工指定</strong>,所以sda3只能表示为编号为3的分区,而不能判断sda设备上已经存在了3个分区</p>
</li>
</ul>
</li>
<li><p>例图</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>硬盘知识</p>
<ul>
<li><p>扇区</p>
<ul>
<li><p>每个扇区容量为512字节(现在有些厂商会设置为4096字节)</p>
<ul>
<li><p>第一个扇区最重要:它保存着主引导记录与分区信息</p>
<ul>
<li><p>主引导记录446字节</p>
</li>
<li><p>分区表为64字节</p>
<ul>
<li><p>每记录一个分区就需要16字节:这样最多只有四个分区信息可以写入到第一个扇区中,这四个分区就是四个主分区</p>
<ul>
<li><p>例图</p>
</li>
<li><p>解决分区个数问题</p>
<ul>
<li><p>可以将第一个分区表中16字节的空间(<strong>扩展分区</strong>)拿出来指向另外一个分区,也就是,<strong>扩展分区不是一个真正的分区</strong>,更像是一个占用16字节分区表空间的指针,<strong>用户一般会用3个主分区加1个扩展分区的方法,然后在扩展分区中创建出数个逻辑分区</strong></p>
<ul>
<li>例图</li>
</ul>
</li>
<li><p>注释：是一块硬盘的第一个扇区512字节，引导记录446字节，分区表64字节…</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>结束符占用2字节</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>软驱:/dev/fd[0-1]</p>
</li>
<li><p>打印机:/dev/lp[0-15]</p>
</li>
<li><p>光驱:/dev/cdrom</p>
</li>
<li><p>鼠标:/dev/mouse</p>
</li>
<li><p>磁带机:/dev/st0或/dev/ht0</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>文件系统与数据资料 6.3</p>
<ul>
<li><p>Ext3</p>
<p>  是一款日志文件系统，能够在系统异常宕机时避免文件系统资料丢失，并能自动修复数据的不一致与错误。然而，当硬盘容量较大时，所需的修复时间也会很长，而且也不能百分之百地保证资料不会丢失。它会把整个磁盘的每个写入动作的细节都预先记录下来，以便在发生异常宕机后能回溯追踪到被中断的部分，然后尝试进行修复。</p>
</li>
<li><p>Ext4(RHEL 6</p>
<p>  Ext3的改进版本，作为RHEL 6系统中的默认文件管理系统，它支持的存储容量高达1EB（1EB=1,073,741,824GB），且能够有无限多的子目录。另外，Ext4文件系统能够批量分配block块，从而极大地提高了读写效率。</p>
</li>
<li><p>XFS(RHEL 7)</p>
<p>  是一种高性能的日志文件系统，而且是RHEL 7中默认的文件管理系统，它的优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的日志功能只用花费极低的计算和存储性能。并且它最大可支持的存储容量为18EB，这几乎满足了所有需求。 </p>
</li>
<li><p>新硬盘必须格式化才能使用,最好分区</p>
</li>
<li><p>Super Block(硬盘地图)</p>
<ul>
<li><p>inode</p>
<ul>
<li><p>Linux并不直接把文件内容写入这个”硬盘地图”,而是把每个文件的权限与属性记录在inode(eye-node索引节点),每个文件占用一个独立的inode表格,该表格大小默认为128字节</p>
<ul>
<li><p>inode里记录的内容</p>
<p>  该文件的访问权限（read、write、execute）；<br>  该文件的所有者与所属组（owner、group）；<br>  该文件的大小（size）；<br>  该文件的创建或内容修改时间（ctime）；<br>  该文件的最后一次访问时间（atime）；<br>  该文件的修改时间（mtime）；<br>  文件的特殊权限（SUID、SGID、SBIT）；<br>  该文件的真实数据地址（point）。</p>
</li>
<li><p>一个inode大小仅为128B,记录一个Block块消耗4B,当inode被写满后,Linux会自动分配出一个Block块,专门用于像inode那样记录其他Block块信息</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>block块</p>
<ul>
<li><p>实际文件储保存在Block块中(大小可以是1KB,2KB或4KB)</p>
<ul>
<li><p>两种情况</p>
<ul>
<li><p>情况1:文件很小（1KB），但依然会占用一个block，因此会潜在地浪费3KB。</p>
</li>
<li><p>情况2:文件很大（5KB），那么会占用两个block（5KB-4KB后剩下的1KB也要占用一个block）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在Win中Block块称之为”<strong>簇</strong>”,也就是格式化时候的:<strong>分配单元大小</strong></p>
</li>
</ul>
</li>
<li><p>Linux内核软件层的: VFS(Virtual File System)虚拟文件系统接口</p>
<ul>
<li><p>用户实际操作文件时就是统一对这个虚拟文件系统进行操作了</p>
<p>  图6-5所示为VFS的架构示意图。从中可见，实际文件系统在VFS下隐藏了自己的特性和细节，这样用户在日常使用时会觉得“文件系统都是一样的”，也就可以随意使用各种命令在任何文件系统中进行各种操作了（比如使用cp命令来复制文件）。</p>
<ul>
<li>图例</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>挂在硬件设备 6.4</p>
<ul>
<li><p>命令</p>
<ul>
<li><p>命令mount:挂在文件系统</p>
<p>  <strong>mount命令</strong>用于挂载文件系统，<strong>格式为“mount 文件系统 挂载目录”</strong>。mount命令中可用的参数及作用如表6-3所示。挂载是在使用硬件设备前所执行的最后一步操作。只需使用mount命令把硬盘设备或分区与一个目录文件进行关联，然后就能在这个目录中看到硬件设备中的数据了。<strong>对于比较新的Linux系统来讲，一般不需要使用-t参数来指定文件系统的类型，Linux系统会自动进行判断。而mount 中的-a参数则厉害了，它会在执行后自动检查/etc/fstab文件中有无疏漏被挂载的设备文件，如果有，则进行自动挂载操作。</strong></p>
<ul>
<li><p>格式:mount 文件系统 挂载的目录</p>
<ul>
<li><p>例子:</p>
<ul>
<li><p>1.挂在/dev/sdb2到/backup目录</p>
<p>  [root@linuxprobe ~]# mount /dev/sdb2 /backup</p>
</li>
<li><p>2.避免重启失效,将“设备文件 挂载目录 格式类型 权限选项 是否备份 是否自检”写入到/etc/fstab文件中</p>
<p>  设备文件<br>  一般为设备的路径+设备名称，也可以写唯一识别码（UUID，Universally Unique Identifier）</p>
<p>  挂载目录<br>  指定要挂载到的目录，需在挂载前创建好  </p>
<p>  格式类型<br>  指定文件系统的格式，比如Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等</p>
<p>  权限选项<br>  若设置为defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async</p>
<p>  是否备份<br>  若为1则开机后使用dump进行磁盘备份，为0则不备份</p>
<p>  是否自检<br>  若为1则开机后自动进行磁盘自检，为0则不自检</p>
<ul>
<li><p>代码</p>
<p>  [root@linuxprobe ~]# vim /etc/fstab  </p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="etc-fstab"><a href="#etc-fstab" class="headerlink" title="/etc/fstab"></a>/etc/fstab</h1><h1 id="Created-by-anaconda-on-Wed-May-4-19-26-23-2017"><a href="#Created-by-anaconda-on-Wed-May-4-19-26-23-2017" class="headerlink" title="Created by anaconda on Wed May 4 19:26:23 2017"></a>Created by anaconda on Wed May 4 19:26:23 2017</h1><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="Accessible-filesystems-by-reference-are-maintained-under-‘-dev-disk’"><a href="#Accessible-filesystems-by-reference-are-maintained-under-‘-dev-disk’" class="headerlink" title="Accessible filesystems, by reference, are maintained under ‘/dev/disk’"></a>Accessible filesystems, by reference, are maintained under ‘/dev/disk’</h1><h1 id="See-man-pages-fstab-5-findfs-8-mount-8-and-or-blkid-8-for-more-info"><a href="#See-man-pages-fstab-5-findfs-8-mount-8-and-or-blkid-8-for-more-info" class="headerlink" title="See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info"></a>See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</h1><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><p>  /dev/mapper/rhel-root / xfs defaults 1 1<br>  UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot xfs defaults 1 2<br>  /dev/mapper/rhel-swap swap swap defaults 0 0<br>  /dev/cdrom /media/cdrom iso9660 defaults 0 0   </p>
<p>  /dev/sdb2 /backup ext4 defaults 0 0</p>
</li>
<li><p>挂在信息的解释预作用</p>
<p>  设备文件<br>  一般为设备的路径+设备名称，也可以写唯一识别码（UUID，Universally Unique Identifier）</p>
<p>  挂载目录<br>  指定要挂载到的目录，需在挂载前创建好  </p>
<p>  格式类型<br>  指定文件系统的格式，比如Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等</p>
<p>  权限选项<br>  若设置为defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async</p>
<p>  是否备份<br>  若为1则开机后使用dump进行磁盘备份，为0则不备份</p>
<p>  是否自检<br>  若为1则开机后自动进行磁盘自检，为0则不自检</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><p>-a:挂在所有在/etc/fstab中定义的文件系统</p>
</li>
<li><p>-t:指定文件系统的类型</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>命令umount:撤销已挂在的设备文件</p>
<ul>
<li><p>格式:umount [挂在点或设备文件]</p>
<p>  卸载操作只需要说明想要取消关联的设备文件或挂载目录的其中一项即可</p>
<ul>
<li><p>例子</p>
<p>  [root@linuxprobe ~]# umount /dev/sdb2</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>添加硬盘设备 6.5</p>
<ul>
<li><p>命令</p>
<ul>
<li><p>命令fdisk:用于管理磁盘分区</p>
<ul>
<li><p>格式为:fdisk [磁盘名称]</p>
<p>  fdisk命令提供了:</p>
<p>  添加\删除\转换分区等功能</p>
<ul>
<li><p>参数</p>
<ul>
<li><p>m:查看全部可用的参数</p>
</li>
<li><p>n:添加新分区</p>
</li>
<li><p>d:删除某个分区信息</p>
</li>
<li><p>l:列出所有可用的分区类型</p>
</li>
<li><p>t:改变某个分区的类型</p>
</li>
<li><p>p:查看分分区表信息</p>
</li>
<li><p>w:保存并退出</p>
</li>
<li><p>q:不保存直接退出</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>命令mkfs:用于对硬件设备格式化</p>
<ul>
<li><p>格式为:mkfs.文件格式 设备文件</p>
</li>
<li><p>在Shell输入mkfs后再敲击两下补全命令TAB键,可以看到可以使用的文件格式</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟机设置</p>
<ul>
<li><p>1.关闭虚拟系统</p>
</li>
<li><p>2.点击虚拟机页面:编辑虚拟机设置</p>
<ul>
<li><p>2-1.点击添加</p>
</li>
<li><p>2-2.选择硬盘</p>
<ul>
<li><p>选择默认SCSI</p>
<ul>
<li><p>选择创建新虚拟磁盘</p>
<ul>
<li><p>设置20GB,选择将虚拟硬盘拆分成多个文件</p>
<ul>
<li><p>设置保存位置(这里采用默认)</p>
<ul>
<li>点击完成</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分区</p>
<ul>
<li><p>第一步:使用fdisk命令尝试管理/dev/sdb硬盘设备</p>
<ul>
<li><p>在看到提示信息后输入参数p来查看硬盘设备内已有的分区信息(其中包括了硬盘容量大小\扇区个数等信息</p>
<ul>
<li><p>例子</p>
<p>  [root@linuxprobe ~]# fdisk /dev/sdb<br>  Welcome to fdisk (util-linux 2.23.2).<br>  Changes will remain in memory only, until you decide to write them.<br>  Be careful before using the write command.<br>  Device does not contain a recognized partition table<br>  Building a new DOS disklabel with disk identifier 0x47d24a34.<br>  Command (m for help): p<br>  Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors<br>  Units = sectors of 1 * 512 = 512 bytes<br>  Sector size (logical/physical): 512 bytes / 512 bytes<br>  I/O size (minimum/optimal): 512 bytes / 512 bytes<br>  Disk label type: dos<br>  Disk identifier: 0x47d24a34<br>  Device Boot Start End Blocks Id System</p>
</li>
</ul>
</li>
<li><p>注释：第一块硬盘为sda，第二块为sdb，第三块为sdc…</p>
</li>
</ul>
</li>
<li><p>第二部:输入参数n尝试创建新分区,系统会要求你继续输入p创建主分区 还是 输入e来创建扩展分区,这里输入p创建一个主分区</p>
<ul>
<li><p>例子</p>
<p>  Command (m for help): n<br>  Partition type:<br>  p primary (0 primary, 0 extended, 4 free)<br>  e extended<br>  Select (default p): p</p>
</li>
</ul>
</li>
<li><p>第三步:输入主分区编号(1~4)这里输入”1”</p>
<ul>
<li><p>然后会提示定义其实扇区位置(这里不需要改动</p>
<ul>
<li><p>最后系统会要求定义分区的结束位置(<strong>定义整个分区大小是多少</strong>),这里输入+2G创建一个容量为2GB的硬盘分区</p>
<ul>
<li><p>例子</p>
<p>  Partition number (1-4, default 1): 1<br>  First sector (2048-41943039, default 2048):此处敲击回车<br>  Using default value 2048<br>  Last sector, +sectors or +size{K,M,G} (2048-41943039, default 41943039): +2G<br>  Partition 1 of type Linux and of size 2 GiB is set</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>第四步:再次使参数p来查看硬盘设备中的分区信息果然就能看到一个名称为/dev/sdb1、起始扇区位置为2048、结束扇区位置为4196351的主分区了。<strong>这时候千万不要直接关闭窗口，而应该敲击参数w后回车，这样分区信息才是真正的写入成功啦。</strong></p>
<ul>
<li><p>例子</p>
<p>  Command (m for help): p<br>  Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors<br>  Units = sectors of 1 * 512 = 512 bytes<br>  Sector size (logical/physical): 512 bytes / 512 bytes<br>  I/O size (minimum/optimal): 512 bytes / 512 bytes<br>  Disk label type: dos<br>  Disk identifier: 0x47d24a34<br>  Device Boot Start End Blocks Id System<br>  /dev/sdb1 2048 4196351 2097152 83 Linux<br>  Command (m for help): w<br>  The partition table has been altered!<br>  Calling ioctl() to re-read partition table.<br>  Syncing disks.</p>
</li>
</ul>
</li>
<li><p>第五步:Linux会自动把整个硬盘分区抽象成/dev/sdb1设备文件,可以使用file命令查看该文件的属性</p>
<ul>
<li><p>有时系统并没有把分区信息同步到Linux内核</p>
<ul>
<li><p>解决办法:输入partprobe手动将分区信息同步到内核(一般连续两次执行该命令比较好),如果还是不行重启就可以了</p>
<ul>
<li><p>例子</p>
<p>  [root@linuxprobe ]# file /dev/sdb1<br>  /dev/sdb1: cannot open (No such file or directory)<br>  [root@linuxprobe ]# partprobe<br>  [root@linuxprobe ]# partprobe<br>  [root@linuxprobe ]# file /dev/sdb1<br>  /dev/sdb1: block special</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>格式化</p>
<ul>
<li><p>命令:mkfs.文件格式 设备文件</p>
<ul>
<li><p>格式分区为XFS的文件系统</p>
<ul>
<li><p>例子</p>
<p>  [root@linuxprobe ~]# mkfs.xfs /dev/sdb1<br>  meta-data=/dev/sdb1 isize=256 agcount=4, agsize=131072 blks<br>   = sectsz=512 attr=2, projid32bit=1<br>   = crc=0<br>  data = bsize=4096 blocks=524288, imaxpct=25<br>   = sunit=0 swidth=0 blks<br>  naming =version 2 bsize=4096 ascii-ci=0 ftype=0<br>  log =internal log bsize=4096 blocks=2560, version=2<br>   = sectsz=512 sunit=0 blks, lazy-count=1<br>  realtime =none extsz=4096 blocks=0, rtextents=0</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>挂载</p>
<ul>
<li><p>命令:mount /目录</p>
<ul>
<li><p>例子</p>
<p>  [root@linuxprobe ~]# mkdir /newFS<br>  [root@linuxprobe ~]# mount /dev/sdb1 /newFS/<br>  [root@linuxprobe ~]# df -h<br>  Filesystem Size Used Avail Use% Mounted on<br>  /dev/mapper/rhel-root 18G 3.5G 15G 20% /<br>  devtmpfs 905M 0 905M 0% /dev<br>  tmpfs 914M 140K 914M 1% /dev/shm<br>  tmpfs 914M 8.8M 905M 1% /run<br>  tmpfs 914M 0 914M 0% /sys/fs/cgroup<br>  /dev/sr0 3.5G 3.5G 0 100% /media/cdrom<br>  /dev/sda1 497M 119M 379M 24% /boot<br>  /dev/sdb1 2.0G 33M 2.0G 2% /newFS</p>
</li>
<li><p>测试</p>
<ul>
<li><p>拷贝文件到新挂载的目录</p>
<ul>
<li>命令:cp -rf /要拷贝的目录/* /目录/</li>
</ul>
</li>
<li><p>查看文件大小</p>
<ul>
<li><p>命令:du [选项] [文件]:查看一个或多个文件占用了多大硬盘空间</p>
<ul>
<li>命令例子:du -sh /目录</li>
</ul>
</li>
</ul>
</li>
<li><p>例子</p>
<p>  [root@linuxprobe ~]# cp -rf /etc/* /newFS/<br>  [root@linuxprobe ~]# ls /newFS/<br>  abrt hosts pulse<br>  adjtime hosts.allow purple<br>  aliases hosts.deny qemu-ga<br>  aliases.db hp qemu-kvm<br>  alsa idmapd.conf radvd.conf<br>  alternatives init.d rc0.d<br>  anacrontab inittab rc1.d<br>  ………………省略部分输入信息………………<br>  [root@linuxprobe ~]# du -sh /newFS/<br>  33M /newFS/</p>
</li>
</ul>
</li>
<li><p>保证不失效</p>
<ul>
<li><p>vim /etc/fstab</p>
<ul>
<li><p>例子</p>
<p>  [root@linuxprobe ~]# vim /etc/fstab  </p>
<h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><h1 id="etc-fstab-1"><a href="#etc-fstab-1" class="headerlink" title="/etc/fstab"></a>/etc/fstab</h1><h1 id="Created-by-anaconda-on-Wed-May-4-19-26-23-2017-1"><a href="#Created-by-anaconda-on-Wed-May-4-19-26-23-2017-1" class="headerlink" title="Created by anaconda on Wed May 4 19:26:23 2017"></a>Created by anaconda on Wed May 4 19:26:23 2017</h1><h1 id="-4"><a href="#-4" class="headerlink" title=""></a></h1><h1 id="Accessible-filesystems-by-reference-are-maintained-under-‘-dev-disk’-1"><a href="#Accessible-filesystems-by-reference-are-maintained-under-‘-dev-disk’-1" class="headerlink" title="Accessible filesystems, by reference, are maintained under ‘/dev/disk’"></a>Accessible filesystems, by reference, are maintained under ‘/dev/disk’</h1><h1 id="See-man-pages-fstab-5-findfs-8-mount-8-and-or-blkid-8-for-more-info-1"><a href="#See-man-pages-fstab-5-findfs-8-mount-8-and-or-blkid-8-for-more-info-1" class="headerlink" title="See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info"></a>See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</h1><h1 id="-5"><a href="#-5" class="headerlink" title=""></a></h1><p>  /dev/mapper/rhel-root / xfs defaults 1 1<br>  UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot xfs defaults 1 2<br>  /dev/mapper/rhel-swap swap swap defaults 0 0<br>  /dev/cdrom /media/cdrom iso9660 defaults 0 0<br>  /dev/sdb1 /newFS xfs defaults 0 0</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>添加交换分区(SWAP) 6.6</p>
<p>  SWAP（交换）分区是一种通过在硬盘中预先划分一定的空间，然后将把内存中暂时不常用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术，其设计目的是为了解决真实物理内存不足的问题。但由于交换分区毕竟是通过硬盘设备读写数据的，速度肯定要比物理内存慢，所以只有当真实的物理内存耗尽后才会调用交换分区的资源。</p>
<ul>
<li><p>实际操作</p>
<p>  交换分区的创建过程与前文讲到的挂载并使用存储设备的过程非常相似。在对/dev/sdb存储设备进行分区操作前，有必要先说一下交换分区的划分建议：在生产环境中，交换分区的大小一般为真实物理内存的1.5～2倍，为了让大家更明显地感受交换分区空间的变化，这里取出一个大小为5GB的主分区作为交换分区资源。在分区创建完毕后保存并退出即可：</p>
<ul>
<li><p>操作实例</p>
<ul>
<li><p>1.使用fdisk新建一个用于SWAP的主分区</p>
<ul>
<li><p>命令集实例</p>
<p>  [root@linuxprobe ~]# fdisk /dev/sdb<br>  Welcome to fdisk (util-linux 2.23.2).<br>  Changes will remain in memory only, until you decide to write them.<br>  Be careful before using the write command.<br>  Device does not contain a recognized partition table<br>  Building a new DOS disklabel with disk identifier 0xb3d27ce1.<br>  Command (m for help): n<br>  Partition type:<br>  p primary (1 primary, 0 extended, 3 free)<br>  e extendedSelect (default p): p<br>  Partition number (2-4, default 2):<br>  First sector (4196352-41943039, default 4196352): 此处敲击回车<br>  Using default value 4196352<br>  Last sector, +sectors or +size{K,M,G} (4196352-41943039, default 41943039): +5G<br>  Partition 2 of type Linux and of size 5 GiB is set<br>  Command (m for help): p<br>  Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors<br>  Units = sectors of 1 * 512 = 512 bytes<br>  Sector size (logical/physical): 512 bytes / 512 bytes<br>  I/O size (minimum/optimal): 512 bytes / 512 bytes<br>  Disk label type: dos<br>  Disk identifier: 0xb0ced57f<br>   Device Boot Start End Blocks Id System<br>  /dev/sdb1 2048 4196351 2097152 83 Linux<br>  /dev/sdb2 4196352 14682111 5242880 83 Linux<br>  Command (m for help): w<br>  The partition table has been altered!<br>  Calling ioctl() to re-read partition table.<br>  WARNING: Re-reading the partition table failed with error 16: Device or resource busy.<br>  The kernel still uses the old table. The new table will be used at<br>  the next reboot or after you run partprobe(8) or kpartx(8)<br>  Syncing disks.</p>
</li>
</ul>
</li>
<li><p>2.使用mkswap(SWAP分区专用的格式化命令)对新建主分区进行格式化操作</p>
<ul>
<li><p>例子:mkswap /dev/sdb2</p>
<p>  [root@linuxprobe ~]# mkswap /dev/sdb2<br>  Setting up swapspace version 1, size = 5242876 KiB<br>  no label, UUID=2972f9cb-17f0-4113-84c6-c64b97c40c75</p>
</li>
</ul>
</li>
<li><p>3.使用swapon命令,把准备好的SWAP分区设备正式挂载到系统中</p>
<ul>
<li><p>命令实例</p>
<p>  [root@linuxprobe ~]# free -m<br>  total used free shared buffers cached<br>  Mem: 1483 782 701 9 0 254<br>  -/+ buffers/cache: 526 957<br>  Swap: 2047 0 2047<br>  [root@linuxprobe ~]# swapon /dev/sdb2<br>  [root@linuxprobe ~]# free -m<br>  total used free shared buffers cached<br>  Mem: 1483 785 697 9 0 254<br>  -/+ buffers/cache: 530 953<br>  Swap: 7167 0 7167</p>
</li>
<li><p>前后使用free -m 查看交换分区大小变化</p>
</li>
</ul>
</li>
<li><ol start="4">
<li><p>vim /etc/fstab 在其中添加相关信息,保证重启后依然生效</p>
<ul>
<li><p>命令实例</p>
<p> [root@linuxprobe ~]# vim /etc/fstab  </p>
<h1 id="-6"><a href="#-6" class="headerlink" title=""></a></h1><h1 id="etc-fstab-2"><a href="#etc-fstab-2" class="headerlink" title="/etc/fstab"></a>/etc/fstab</h1><h1 id="Created-by-anaconda-on-Wed-May-4-19-26-23-2017-2"><a href="#Created-by-anaconda-on-Wed-May-4-19-26-23-2017-2" class="headerlink" title="Created by anaconda on Wed May 4 19:26:23 2017"></a>Created by anaconda on Wed May 4 19:26:23 2017</h1><h1 id="-7"><a href="#-7" class="headerlink" title=""></a></h1><h1 id="Accessible-filesystems-by-reference-are-maintained-under-‘-dev-disk’-2"><a href="#Accessible-filesystems-by-reference-are-maintained-under-‘-dev-disk’-2" class="headerlink" title="Accessible filesystems, by reference, are maintained under ‘/dev/disk’"></a>Accessible filesystems, by reference, are maintained under ‘/dev/disk’</h1><h1 id="See-man-pages-fstab-5-findfs-8-mount-8-and-or-blkid-8-for-more-info-2"><a href="#See-man-pages-fstab-5-findfs-8-mount-8-and-or-blkid-8-for-more-info-2" class="headerlink" title="See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info"></a>See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</h1><h1 id="-8"><a href="#-8" class="headerlink" title=""></a></h1><p> /dev/mapper/rhel-root / xfs defaults 1 1<br> UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot xfs defaults 1 2<br> /dev/mapper/rhel-swap swap swap defaults 0 0<br> /dev/cdrom /media/cdrom iso9660 defaults 0 0<br> /dev/sdb1 /newFS xfs defaults 0 0<br> /dev/sdb2 swap swap defaults 0 0 </p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>建议:大小是物理内存的1.5-2倍</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘容量配额 6.7</p>
<p>  本书在前面曾经讲到，Linux系统的设计初衷就是让许多人一起使用并执行各自的任务，从而成为多用户、多任务的操作系统。但是，硬件资源是固定且有限的，如果某些用户不断地在Linux系统上创建文件或者存放电影，硬盘空间总有一天会被占满。针对这种情况，root管理员就需要使用磁盘容量配额服务来限制某位用户或某个用户组针对特定文件夹可以使用的最大硬盘空间或最大文件个数，一旦达到这个最大值就不再允许继续使用。可以使用quota命令进行磁盘容量配额管理，从而限制用户的硬盘可用容量或所能创建的最大文件个数。quota命令还有软限制和硬限制的功能。</p>
<ul>
<li><p>使用命令:quota命令进行磁盘容量配额管理,从而限制用户硬盘的可用容量或所能创建的最大文件个数</p>
<ul>
<li><p>quota命令的软限制和硬限制</p>
<ul>
<li><p>软限制:当达到软限制时会提示用户,但仍允许用户在限定的额度内继续使用</p>
</li>
<li><p>硬限制: 当达到硬限制时会提示用户,且强制终止用户的操作</p>
</li>
</ul>
</li>
<li><p>配置quota服务</p>
<p>  RHEL 7 中已经安装了quota磁盘容量配额服务程序包,但存储设备却默认没有开启对quota的支持</p>
<ul>
<li><p>命令集实例</p>
<p>  [root@linuxprobe ~]# vim /etc/fstab</p>
<h1 id="-9"><a href="#-9" class="headerlink" title=""></a></h1><h1 id="etc-fstab-3"><a href="#etc-fstab-3" class="headerlink" title="/etc/fstab"></a>/etc/fstab</h1><h1 id="Created-by-anaconda-on-Wed-May-4-19-26-23-2017-3"><a href="#Created-by-anaconda-on-Wed-May-4-19-26-23-2017-3" class="headerlink" title="Created by anaconda on Wed May 4 19:26:23 2017"></a>Created by anaconda on Wed May 4 19:26:23 2017</h1><h1 id="-10"><a href="#-10" class="headerlink" title=""></a></h1><h1 id="Accessible-filesystems-by-reference-are-maintained-under-‘-dev-disk’-3"><a href="#Accessible-filesystems-by-reference-are-maintained-under-‘-dev-disk’-3" class="headerlink" title="Accessible filesystems, by reference, are maintained under ‘/dev/disk’"></a>Accessible filesystems, by reference, are maintained under ‘/dev/disk’</h1><h1 id="See-man-pages-fstab-5-findfs-8-mount-8-and-or-blkid-8-for-more-info-3"><a href="#See-man-pages-fstab-5-findfs-8-mount-8-and-or-blkid-8-for-more-info-3" class="headerlink" title="See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info"></a>See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</h1><h1 id="-11"><a href="#-11" class="headerlink" title=""></a></h1><p>  /dev/mapper/rhel-root / xfs defaults 1 1<br>  UUID=812b1f7c-8b5b-43da-8c06-b9999e0fe48b /boot xfs defaults,uquota 1 2<br>  /dev/mapper/rhel-swap swap swap defaults 0 0<br>  /dev/cdrom /media/cdrom iso9660 defaults 0 0<br>  /dev/sdb1 /newFS xfs defaults 0 0<br>  /dev/sdb2 swap swap defaults 0 0<br>  [root@linuxprobe ~]# reboot<br>  [root@linuxprobe ~]# mount | grep boot<br>  /dev/sda1 on /boot type xfs (rw,relatime,seclabel,attr2,inode64,usrquota)</p>
<ul>
<li>1.使用 “vim /etc/fstab “打开配置文件<br>2.在其中找到”/dev/mapper/rhel-root/“这一行中的”defaults”在后面新增一个参数uquota,保存退出vim<br>3.使用reboot命令重启系统<br>4.使用mount | grep boot 查找挂在的所有内容,并筛选出包含boot的哪一行</li>
</ul>
</li>
<li><p>创建一个用于检查quota磁盘容量配额效果的用户tom,并针对/boot目录增加其他人的写权限,保证用户能正常写入数据</p>
<ul>
<li><p>命令集</p>
<ul>
<li><p>useradd tom</p>
<ul>
<li>chmod -Rf o+w /boot</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>xfs_quota与edquota命令</p>
<ul>
<li><p>命令 xfs_quota : 专门对阵XFS文件系统来管理quota磁盘容量配额服务的命令</p>
<ul>
<li><p>格式为:xfs_quota [参数] 配额 文件系统</p>
<ul>
<li><p>参数</p>
<ul>
<li><p>-c:用于以参数的形式设置要执行的程序</p>
</li>
<li><p>-x:专家模式</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>命令集实例:我们使用xfs_quota命令来设置用户tom对/boot目录的quota磁盘容量配额。具体的限额控制包括：硬盘使用量的软限制和硬限制分别为3MB和6MB；创建文件数量的软限制和硬限制分别为3个和6个</p>
<ul>
<li><p>实例</p>
<p>  [root@linuxprobe ~]# xfs_quota -x -c ‘limit bsoft=3m bhard=6m isoft=3 ihard=6 tom’ /boot<br>  [root@linuxprobe ~]# xfs_quota -x -c report /boot<br>  User quota on /boot (/dev/sda1)   Blocks<br>  User ID Used Soft Hard Warn/Grace  </p>
<hr>
<p>  root 95084 0 0 00 [——–]<br>  tom 0 3072 6144 00 [——–]<br>  当配置好上述的各种软硬限制后，尝试切换到这个普通用户，然后分别尝试创建一个体积为5MB和8MB的文件。可以发现，在创建8MB的文件时受到了系统限制：<br>  [root@linuxprobe ~]# su - tom<br>  [tom@linuxprobe ~]$ dd if=/dev/zero of=/boot/tom bs=5M count=1<br>  1+0 records in<br>  1+0 records out<br>  5242880 bytes (5.2 MB) copied, 0.123966 s, 42.3 MB/s<br>  [tom@linuxprobe ~]$ dd if=/dev/zero of=/boot/tom bs=8M count=1<br>  dd: error writing ‘/boot/tom’: Disk quota exceeded<br>  1+0 records in<br>  0+0 records out<br>  6291456 bytes (6.3 MB) copied, 0.0201593 s, 312 MB/s</p>
<ul>
<li><p>1.xfs_quota -x -c ‘limit bsoft=3m bhard=6m isoft=3 ihard=6 tom’ /boot</p>
<p>2.xfs_quota -x -c report /boot  </p>
<p>当配置好上述的各种软硬限制后，尝试切换到这个普通用户，然后分别尝试创建一个体积为5MB和8MB的文件。可以发现，在创建8MB的文件时受到了系统限制：</p>
<p>3.su - tom  </p>
<p>4.dd if=/dev/zero of=/boot/tom bs=5M count=1  </p>
<p>5.dd if=/dev/zero of=/boot/tom bs=8M count=1</p>
<ul>
<li><p>xfs_quota命令</p>
<ul>
<li><p>参数</p>
<ul>
<li><p>-x:专家模式</p>
</li>
<li><p>-c:用于以参数的形式设置要执行的程序</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>dd命令</p>
<ul>
<li><p>参数解释</p>
<pre><code>  1.    if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;
  2.    of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;
  3.    ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。 obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。 bs=bytes：同时设置读入/输出的块大小为bytes个字节。
  4.    cbs=bytes：一次转换bytes个字节，即指定转换缓冲区大小。
  5.    skip=blocks：从输入文件开头跳过blocks个块后再开始复制。
  6.    seek=blocks：从输出文件开头跳过blocks个块后再开始复制。 注意：通常只用当输出文件是磁盘或磁带时才有效，即备份到磁盘或磁带时才有效。
  7.    count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。
  8.    conv=conversion：用指定的参数转换文件。
  ◦    ascii：转换ebcdic为ascii
  ◦    ebcdic：转换ascii为ebcdic
  ◦    ibm：转换ascii为alternate ebcdic
  ◦    block：把每一行转换为长度为cbs，不足部分用空格填充
  ◦    unblock：使每一行的长度都为cbs，不足部分用空格填充
  ◦    lcase：把大写字符转换为小写字符
  ◦    ucase：把小写字符转换为大写字符
  ◦    swab：交换输入的每对字节
  ◦    noerror：出错时不停止
  ◦    notrunc：不截短输出文件
  ◦    sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</code></pre><ul>
<li><p>网站</p>
<p>  <a href="https://www.cnblogs.com/ginvip/p/6370836.html" target="_blank" rel="noopener">https://www.cnblogs.com/ginvip/p/6370836.html</a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>edquota命令 : 编辑用户的quota配置限额</p>
<ul>
<li><p>格式:edquota [参数] [用户]</p>
<ul>
<li><p>参数</p>
<ul>
<li><p>-u:表示要针对那个用户进行设置</p>
</li>
<li><p>-g:表示要针对那个用户组进行设置</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>实例:把tom用户的硬限额从5MB提升到8MB</p>
<ul>
<li><p>命令集实例</p>
<p>  [root@linuxprobe ~]# edquota -u tom<br>  Disk quotas for user tom (uid 1001):<br>   Filesystem blocks soft hard inodes soft hard<br>   /dev/sda1 6144 3072 8192 1 3 6<br>  [root@linuxprobe ~]# su - tom<br>  Last login: Mon Sep 7 16:43:12 CST 2017 on pts/0<br>  [tom@linuxprobe ~]$ dd if=/dev/zero of=/boot/tom bs=8M count=1<br>  1+0 records in<br>  1+0 records out<br>  8388608 bytes (8.4 MB) copied, 0.0268044 s, 313 MB/s<br>  [tom@linuxprobe ~]$ dd if=/dev/zero of=/boot/tom bs=10M count=1<br>  dd: error writing ‘/boot/tom’: Disk quota exceeded<br>  1+0 records in<br>  0+0 records out<br>  8388608 bytes (8.4 MB) copied, 0.167529 s, 50.1 MB/s</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>提示:早期Linux系统和RHEL 6 使用的是 usrquota参数,而RHEL 7使用的是uquota参数</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>软硬方式链接 6.8</p>
<p>  在Windows系统中，快捷方式就是指向原始文件的一个链接文件，可以让用户从不同的位置来访问原始的文件；原文件一旦被删除或剪切到其他地方后，会导致链接文件失效。但是，这个看似简单的东西在Linux系统中可不太一样。<br>  在Linux系统中存在硬链接和软连接两种文件。<br>  <strong>硬链接（hard link）：</strong>可以将它理解为一个“指向原始文件inode的指针”，系统不为它分配独立的inode和文件。所以，硬链接文件与原始文件其实是同一个文件，只是名字不同。我们每添加一个硬链接，该文件的inode连接数就会增加1；而且只有当该文件的inode连接数为0时，才算彻底将它删除。换言之，由于硬链接实际上是指向原文件inode的指针，因此即便原始文件被删除，依然可以通过硬链接文件来访问。需要注意的是，由于技术的局限性，我们不能跨分区对目录文件进行链接。<br>  <strong>软链接（也称为符号链接[symbolic link]）：</strong>仅仅包含所链接文件的路径名，因此能链接目录文件，也可以跨越文件系统进行链接。但是，当原始文件被删除后，链接文件也将失效，从这一点上来说与Windows系统中的“快捷方式”具有一样的性质。</p>
<ul>
<li><p><strong>软硬链接介绍</strong></p>
<ul>
<li><p><strong>硬链接（hard link）：</strong>可以将它理解为一个“指向原始文件inode的指针”，系统不为它分配独立的inode和文件。所以，硬链接文件与原始文件其实是同一个文件，只是名字不同。我们每添加一个硬链接，该文件的inode连接数就会增加1；而且只有当该文件的inode连接数为0时，才算彻底将它删除。换言之，由于硬链接实际上是指向原文件inode的指针，因此即便原始文件被删除，依然可以通过硬链接文件来访问。需要注意的是，由于技术的局限性，<strong>我们不能跨分区对目录文件进行链接。</strong></p>
</li>
<li><p><strong>软链接（也称为符号链接[symbolic link]）：</strong>仅仅包含所链接文件的路径名，因此能链接目录文件，也可以跨越文件系统进行链接。但是，当原始文件被删除后，链接文件也将失效，从这一点上来说与Windows系统中的“快捷方式”具有一样的性质。</p>
</li>
</ul>
</li>
<li><p><strong>命令</strong></p>
<ul>
<li><p><strong>ln命令 : 用于创建链接文件</strong></p>
<p>  n命令用于创建链接文件，格式为“ln [选项] 目标”，其可用的参数以及作用如表6-6所示。在使用ln命令时，是否添加-s参数，将创建出性质不同的两种“快捷方式”。因此如果没有扎实的理论知识和实践经验做铺垫，尽管能够成功完成实验，但永远不会明白为什么会成功。</p>
<ul>
<li><p><strong>格式为 : ln [选项] 目标</strong></p>
<ul>
<li><p><strong>命令</strong></p>
<ul>
<li><p><strong>-s : 创建”符号链接”(如果不带-s参数,则默认创建硬链接)</strong></p>
</li>
<li><p><strong>-f:强制创建文件或目录的链接</strong></p>
</li>
<li><p><strong>-i:覆盖先前询问</strong></p>
</li>
<li><p><strong>-v:显示创建链接的过程</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>实例</strong></p>
<p>  为了更好地理解软链接、硬链接的不同性质，接下来创建一个类似于Windows系统中快捷方式的软链接。这样，当原始文件被删除后，就无法读取新建的链接文件了。<br>  [root@linuxprobe ~]# echo “Welcome to linuxprobe.com” &gt; readme.txt<br>  [root@linuxprobe ~]# ln -s readme.txt readit.txt<br>  [root@linuxprobe ~]# cat readme.txt<br>  Welcome to linuxprobe.com<br>  [root@linuxprobe ~]# cat readit.txt<br>  Welcome to linuxprobe.com<br>  [root@linuxprobe ~]# ls -l readme.txt<br>  -rw-r–r– 1 root root 26 Jan 11 00:08 readme.txt<br>  [root@linuxprobe ~]# rm -f readme.txt<br>  [root@linuxprobe ~]# cat readit.txt<br>  cat: readit.txt: No such file or directory<br>  接下来针对一个原始文件创建一个硬链接，即相当于针对原始文件的硬盘存储位置创建了一个指针，这样一来，新创建的这个硬链接就不再依赖于原始文件的名称等信息，也不会因为原始文件的删除而导致无法读取。同时可以看到创建硬链接后，原始文件的硬盘链接数量增加到了2。<br>  [root@linuxprobe ~]# echo “Welcome to linuxprobe.com” &gt; readme.txt<br>  [root@linuxprobe ~]# ln readme.txt readit.txt<br>  [root@linuxprobe ~]# cat readme.txt<br>  Welcome to linuxprobe.com<br>  [root@linuxprobe ~]# cat readit.txt<br>  Welcome to linuxprobe.com<br>  [root@linuxprobe ~]# ls -l readme.txt<br>  -rw-r–r– 2 root root 26 Jan 11 00:13 readme.txt<br>  [root@linuxprobe ~]# rm -f readme.txt<br>  [root@linuxprobe ~]# cat readit.txt<br>  Welcome to linuxprobe.com</p>
</li>
</ul>
</li>
<li></li>
<li><p>问题\疑惑与解决</p>
<ul>
<li>抽象是什么意思</li>
</ul>
</li>
</ul>
<h3 id="第七章-使用RAID与LVM磁盘阵列技术"><a href="#第七章-使用RAID与LVM磁盘阵列技术" class="headerlink" title="第七章 使用RAID与LVM磁盘阵列技术"></a>第七章 使用RAID与LVM磁盘阵列技术</h3><p>在学习了第6章讲解的硬盘设备分区、格式化、挂载等知识后，本章将深入讲解各个常用RAID（Redundant Array of Independent Disks，独立冗余磁盘阵列）技术方案的特性，并通过实际部署RAID 10、RAID 5+备份盘等方案来更直观地查看RAID的强大效果，以便进一步满足生产环境对硬盘设备的IO读写速度和数据冗余备份机制的需求。同时，考虑到用户可能会动态调整存储资源，本章还将介绍LVM（Logical Volume Manager，逻辑卷管理器）的部署、扩容、缩小、快照以及卸载删除的相关知识。相信读者在学完本章内容后，便可以在企业级生产环境中灵活运用RAID和LVM来满足对存储资源的高级管理需求了。</p>
<p>**本章目录结构 [<a href="https://www.linuxprobe.com/chapter-07.html#" target="_blank" rel="noopener">收起</a>]<br>        <a href="https://www.linuxprobe.com/chapter-07.html#71_RAID" target="_blank" rel="noopener">7.1 RAID磁盘冗余阵列</a><br>        <a href="https://www.linuxprobe.com/chapter-07.html#711" target="_blank" rel="noopener">7.1.1  部署磁盘阵列</a><br>        <a href="https://www.linuxprobe.com/chapter-07.html#712" target="_blank" rel="noopener">7.1.2  损坏磁盘阵列及修复</a><br>        <a href="https://www.linuxprobe.com/chapter-07.html#713" target="_blank" rel="noopener">7.1.3  磁盘阵列+备份盘</a><br>        <a href="https://www.linuxprobe.com/chapter-07.html#72_LVM" target="_blank" rel="noopener">7.2 LVM逻辑卷管理器</a><br>        <a href="https://www.linuxprobe.com/chapter-07.html#721" target="_blank" rel="noopener">7.2.1 部署逻辑卷</a><br>        <a href="https://www.linuxprobe.com/chapter-07.html#722" target="_blank" rel="noopener">7.2.2 扩容逻辑卷</a><br>        <a href="https://www.linuxprobe.com/chapter-07.html#723" target="_blank" rel="noopener">7.2.3 缩小逻辑卷</a><br>        <a href="https://www.linuxprobe.com/chapter-07.html#724" target="_blank" rel="noopener">7.2.4 逻辑卷快照</a><br>        <a href="https://www.linuxprobe.com/chapter-07.html#725" target="_blank" rel="noopener">7.2.5 删除逻辑卷</a></p>
<ul>
<li><p>RAID</p>
<ul>
<li><p>版本</p>
<ul>
<li><p>RAID0(只提升速度没有安全性)</p>
<p>  RAID 0技术把多块物理硬盘设备（至少两块）通过硬件或软件的方式串联在一起，组成一个大的卷组，并将数据依次写入到各个物理硬盘中。这样一来，在最理想的状态下，硬盘设备的读写性能会提升数倍，但是若任意一块硬盘发生故障将导致整个系统的数据都受到破坏。通俗来说，RAID 0技术能够有效地提升硬盘数据的吞吐速度，但是不具备数据备份和错误修复能力。如图7-1所示，数据被分别写入到不同的硬盘设备中，即disk1和disk2硬盘设备会分别保存数据资料，最终实现提升读取、写入速度的效果。</p>
<ul>
<li></li>
</ul>
</li>
<li><p>RAID1(提升安全性没有速度)</p>
<p>  尽管RAID 0技术提升了硬盘设备的读写速度，但是它是将数据依次写入到各个物理硬盘中，也就是说，它的数据是分开存放的，其中任何一块硬盘发生故障都会损坏整个系统的数据。因此，如果生产环境对硬盘设备的读写速度没有要求，而是希望增加数据的安全性时，就需要用到RAID 1技术了。<br>  在图7-2所示的RAID 1技术示意图中可以看到，它是把两块以上的硬盘设备进行绑定，在写入数据时，是将数据同时写入到多块硬盘设备上（可以将其视为数据的镜像或备份）。当其中某一块硬盘发生故障后，一般会立即自动以热交换的方式来恢复数据的正常使用。</p>
<p>  RAID 1技术虽然十分注重数据的安全性，但是因为是在多块硬盘设备中写入了相同的数据，因此硬盘设备的利用率得以下降，从理论上来说，图7-2所示的硬盘空间的真实可用率只有50%，由三块硬盘设备组成的RAID 1磁盘阵列的可用率只有33%左右，以此类推。而且，由于需要把数据同时写入到两块以上的硬盘设备，这无疑也在一定程度上增大了系统计算功能的负载。<br>  那么，有没有一种RAID方案既考虑到了硬盘设备的读写速度和数据安全性，还兼顾了成本问题呢？实际上，单从数据安全和成本问题上来讲，就不可能在保持原有硬盘设备的利用率且还不增加新设备的情况下，能大幅提升数据的安全性。<a href="https://www.linuxprobe.com/" target="_blank" rel="noopener">刘遄</a>老师也没有必要忽悠各位读者，下面将要讲解的RAID 5技术虽然在理论上兼顾了三者（读写速度、数据安全性、成本），但实际上更像是对这三者的“相互妥协”。</p>
<ul>
<li></li>
</ul>
</li>
<li><p>RAID5(有速度,有安全性)</p>
<p>  RAID5技术是把硬盘设备的数据奇偶校验信息保存到其他硬盘设备中。RAID 5磁盘阵列组中数据的奇偶校验信息并不是单独保存到某一块硬盘设备中，而是存储到除自身以外的其他每一块硬盘设备上，这样的好处是其中任何一设备损坏后不至于出现致命缺陷；图7-3中parity部分存放的就是数据的奇偶校验信息，换句话说，就是RAID 5技术实际上没有备份硬盘中的真实数据信息，而是当硬盘设备出现问题后通过奇偶校验信息来尝试重建损坏的数据。RAID这样的技术特性“妥协”地兼顾了硬盘设备的读写速度、数据安全性与存储成本问题。</p>
<ul>
<li></li>
</ul>
</li>
<li><p>RAID10(RAID 0和1的结合版)</p>
<p>  鉴于RAID 5技术是因为硬盘设备的成本问题对读写速度和数据的安全性能而有了一定的妥协，但是大部分企业更在乎的是数据本身的价值而非硬盘价格，因此生产环境中主要使用RAID 10技术。<br>  顾名思义，RAID 10技术是RAID 1+RAID 0技术的一个“组合体”。如图7-4所示，RAID 10技术需要至少4块硬盘来组建，其中先分别两两制作成RAID 1磁盘阵列，以保证数据的安全性；然后再对两个RAID 1磁盘阵列实施RAID 0技术，进一步提高硬盘设备的读写速度。这样从理论上来讲，只要坏的不是同一组中的所有硬盘，那么最多可以损坏50%的硬盘设备而不丢失数据。由于RAID 10技术继承了RAID 0的高读写速度和RAID 1的数据安全性，在不考虑成本的情况下RAID 10的性能都超过了RAID 5，因此当前成为广泛使用的一种存储技术。</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li><p>[部署]设置磁盘阵列</p>
<ul>
<li><p>命令 : mdadm</p>
<p>  mdadm<a href="https://www.linuxcool.com/" target="_blank" rel="noopener">命令</a>用于管理<a href="https://www.linuxprobe.com/" target="_blank" rel="noopener">Linux系统</a>中的软件RAID硬盘阵列，格式为“mdadm [模式] &lt;RAID设备名称&gt; [选项] [成员设备名称]”。</p>
<ul>
<li><p>格式:mdadm [模式] &lt;RAID设备名称&gt; [选项] [成员设备名称]</p>
<ul>
<li><p>参数</p>
<ul>
<li><p>-a</p>
<ul>
<li><p>管理模式中是添加磁盘的意思</p>
</li>
<li><p>创建模式中是自动创建设备文件的意思</p>
<ul>
<li>-a yes:自动创建设备文件</li>
</ul>
</li>
</ul>
</li>
<li><p>-n:指定设备数量(使用几块硬盘)</p>
<ul>
<li><p>英文—</p>
<ul>
<li>猜测:num</li>
</ul>
</li>
</ul>
</li>
<li><p>-l:指定RAID级别</p>
<ul>
<li>英文:Level</li>
</ul>
</li>
<li><p>-C:创建</p>
<ul>
<li>英文:Create</li>
</ul>
</li>
<li><p>-v:显示过程</p>
<ul>
<li>英文:Verbose</li>
</ul>
</li>
<li><p>-f:模拟设备损坏</p>
<ul>
<li>英文:Force</li>
</ul>
</li>
<li><p>-r:移除设备</p>
<ul>
<li>英文:Remove</li>
</ul>
</li>
<li><p>-Q:查看摘要信息</p>
<ul>
<li>英文:Query</li>
</ul>
</li>
<li><p>-D:查看详细信息</p>
<ul>
<li>英文Detail</li>
</ul>
</li>
<li><p>-S:停止RAID磁盘阵列</p>
<ul>
<li>英文STOP</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>开始部署:</p>
<ul>
<li><p>1.让虚拟机有四块硬盘(不算第一块系统盘</p>
</li>
<li><p>2.使用mdadm命令组建RAID</p>
<ul>
<li><p><strong>命令:</strong>mdadm -Cv /dev/md0 -a yes -n 4 -l 10 /dev/sdb /dev/sdc /dev/sdd /dev/sde<br><strong>组建RAID</strong></p>
<ul>
<li><p>参数解释</p>
<ul>
<li><p>-C:代表创建一个RAID阵列卡;  </p>
<p>-v:显示创建过程;  </p>
<p>/dev/md0 : 设备名称;  </p>
<p>-a yes : 自动创建设备文件(-a应该是AUTO的意思;  </p>
<p>-n 4:代表使用4块硬盘来部署这个RAID磁盘阵列;  </p>
<p>-l 10 :代表使用RAID 10 方案;  </p>
<p>最后加上的是四块硬盘的设备名称;</p>
</li>
</ul>
</li>
<li><p>命令实例</p>
<p>  [root@linuxprobe ~]# mdadm -Cv /dev/md0 -a yes -n 4 -l 10 /dev/sdb /dev/sdc /dev/sdd /dev/sde<br>  mdadm: layout defaults to n2<br>  mdadm: layout defaults to n2<br>  mdadm: chunk size defaults to 512K<br>  mdadm: size set to 20954624K<br>  mdadm: Defaulting to version 1.2 metadata<br>  mdadm: array /dev/md0 started.</p>
</li>
</ul>
</li>
<li><p>2-1.如果执行RAID化命令时显示没有找到这个硬盘的目录或文件,就先使用fdisk命令对其进行分区</p>
</li>
</ul>
</li>
<li><p>3.把制作好的RAID磁盘阵列格式化为ext4格式</p>
<ul>
<li><p>命令:mkfs.ext4 /dev/md0</p>
<ul>
<li><p>命令实例</p>
<p>  [root@linuxprobe ~]# mkfs.ext4 /dev/md0<br>  mke2fs 1.42.9 (28-Dec-2013)<br>  Filesystem label=<br>  OS type: Linux<br>  Block size=4096 (log=2)<br>  Fragment size=4096 (log=2)<br>  Stride=128 blocks, Stripe width=256 blocks<br>  2621440 inodes, 10477312 blocks<br>  523865 blocks (5.00%) reserved for the super user<br>  First data block=0<br>  Maximum filesystem blocks=2157969408<br>  320 block groups<br>  32768 blocks per group, 32768 fragments per group<br>  8192 inodes per group<br>  Superblock backups stored on blocks:<br>  32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,<br>  4096000, 7962624<br>  Allocating group tables: done<br>  Writing inode tables: done<br>  Creating journal (32768 blocks): done<br>  Writing superblocks and filesystem accounting information: done</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>4.创建挂载点,然后把硬盘设备进行挂在操作</p>
<ul>
<li><p>命令实例</p>
<p>  [root@linuxprobe ~]# mkdir /RAID<br>  [root@linuxprobe ~]# mount /dev/md0 /RAID<br>  [root@linuxprobe ~]# df -h<br>  Filesystem Size Used Avail Use% Mounted on<br>  /dev/mapper/rhel-root 18G 3.0G 15G 17% /<br>  devtmpfs 905M 0 905M 0% /dev<br>  tmpfs 914M 84K 914M 1% /dev/shm<br>  tmpfs 914M 8.9M 905M 1% /run<br>  tmpfs 914M 0 914M 0% /sys/fs/cgroup<br>  /dev/sr0 3.5G 3.5G 0 100% /media/cdrom<br>  /dev/sda1 497M 119M 379M 24% /boot<br>  /dev/md0 40G 49M 38G 1% /RAID</p>
</li>
</ul>
</li>
<li><p>5.最后检查/dev/md0磁盘阵列的详细信息,<strong>并把挂在信息写入到配置文件中</strong></p>
<ul>
<li><p>挂在命令实例(使用echo”” &gt;&gt; 配置文件,其中”&gt;&gt;”,是追加文件的意思)</p>
<ul>
<li><p><strong>命令实例</strong></p>
<p>  [root@linuxprobe ~]# mdadm -D /dev/md0<br>  /dev/md0:<br>  Version : 1.2<br>  Creation Time : Tue May 5 07:43:26 2017<br>  Raid Level : raid10<br>  Array Size : 41909248 (39.97 GiB 42.92 GB)<br>  Used Dev Size : 20954624 (19.98 GiB 21.46 GB)<br>  Raid Devices : 4<br>  Total Devices : 4<br>  Persistence : Superblock is persistent<br>  Update Time : Tue May 5 07:46:59 2017<br>  State : clean<br>  Active Devices : 4<br>  Working Devices : 4<br>  Failed Devices : 0<br>  Spare Devices : 0<br>  Layout : near=2<br>  Chunk Size : 512K<br>  Name : localhost.localdomain:0 (local to host localhost.localdomain)<br>  UUID : cc9a87d4:1e89e175:5383e1e8:a78ec62c<br>  Events : 17<br>  Number Major Minor RaidDevice State<br>  0 8 16 0 active sync /dev/sdb<br>  1 8 32 1 active sync /dev/sdc<br>  2 8 48 2 active sync /dev/sdd<br>  3 8 64 3 active sync /dev/sde<br>  [root@linuxprobe ~]# echo “/dev/md0 /RAID ext4 defaults 0 0” &gt;&gt; /etc/fstab</p>
</li>
</ul>
</li>
<li><p>查看信息命令:mdadm -D /dev/md0</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>[恢复]损坏磁盘阵列即修复</p>
<ul>
<li><p>1.首先确认有一块物理硬盘设备出现损坏不能再继续正常使用后，应该使用mdadm命令来予以移除之后查看下RAID磁盘阵列组的状态已经被改变</p>
<ul>
<li><p>命令实例</p>
<p>  [root@linuxprobe ~]# mdadm /dev/md0 -f /dev/sdb<br>  mdadm: set /dev/sdb faulty in /dev/md0<br>  [root@linuxprobe ~]# mdadm -D /dev/md0<br>  /dev/md0:<br>  Version : 1.2<br>  Creation Time : Fri May 8 08:11:00 2017<br>  Raid Level : raid10<br>  Array Size : 41909248 (39.97 GiB 42.92 GB)<br>  Used Dev Size : 20954624 (19.98 GiB 21.46 GB)<br>  Raid Devices : 4<br>  Total Devices : 4<br>  Persistence : Superblock is persistent<br>  Update Time : Fri May 8 08:27:18 2017<br>  State : clean, degraded<br>  Active Devices : 3<br>  Working Devices : 3<br>  Failed Devices : 1<br>  Spare Devices : 0<br>  Layout : near=2<br>  Chunk Size : 512K<br>  Name : linuxprobe.com:0 (local to host linuxprobe.com)<br>  UUID : f2993bbd:99c1eb63:bd61d4d4:3f06c3b0<br>  Events : 21<br>  Number Major Minor RaidDevice State<br>  0 0 0 0 removed<br>  1 8 32 1 active sync /dev/sdc<br>  2 8 48 2 active sync /dev/sdd<br>  3 8 64 3 active sync /dev/sde<br>  0 8 16 - faulty /dev/sdb</p>
<ul>
<li>在RAID 10级别的磁盘阵列中，当RAID 1磁盘阵列中存在一个故障盘时并不影响RAID 10磁盘阵列的使用。当购买了新的硬盘设备后再使用mdadm命令来予以替换即可，在此期间我们可以在/RAID目录中正常地创建或删除文件。由于我们是在虚拟机中模拟硬盘，所以先重启系统，然后再把新的硬盘添加到RAID磁盘阵列中。</li>
</ul>
</li>
</ul>
</li>
<li><p>2.在RAID 10级别的磁盘阵列中，当<strong>RAID 1磁盘阵列中存在一个故障盘时并不影响RAID 10磁盘阵列的使用</strong>。当购买了新的硬盘设备后再使用mdadm命令来予以替换即可，<strong>在此期间我们可以在/RAID目录中正常地创建或删除文件</strong>。由于我们是在虚拟机中模拟硬盘，所以先重启系统，然后再把新的硬盘添加到RAID磁盘阵列中</p>
<ul>
<li><p>命令实例</p>
<p>  [root@linuxprobe ~]# umount /RAID<br>  [root@linuxprobe ~]# mdadm /dev/md0 -a /dev/sdb<br>  [root@linuxprobe ~]# mdadm -D /dev/md0<br>  /dev/md0:<br>   Version : 1.2<br>   Creation Time : Mon Jan 30 00:08:56 2017<br>   Raid Level : raid10<br>   Array Size : 41909248 (39.97 GiB 42.92 GB)<br>   Used Dev Size : 20954624 (19.98 GiB 21.46 GB)<br>   Raid Devices : 4<br>   Total Devices : 4<br>   Persistence : Superblock is persistent<br>   Update Time : Mon Jan 30 00:19:53 2017<br>   State : clean<br>   Active Devices : 4<br>  Working Devices : 4<br>   Failed Devices : 0<br>   Spare Devices : 0<br>   Layout : near=2<br>   Chunk Size : 512K<br>   Name : localhost.localdomain:0 (local to host localhost.localdomain)<br>   UUID : d3491c05:cfc81ca0:32489f04:716a2cf0<br>   Events : 56<br>   Number Major Minor RaidDevice State<br>   4 8 16 0 active sync /dev/sdb<br>   1 8 32 1 active sync /dev/sdc<br>   2 8 48 2 active sync /dev/sdd<br>   3 8 64 3 active sync /dev/sde<br>  [root@linuxprobe ~]# mount -a</p>
<ul>
<li><p>使用的命令</p>
<ul>
<li>1.umount /RAID (卸载文件系统) 2.mdadm /dev/md0 -a /dev/sdb 3.mdadm -D /dev/md0 4.mount -a(将/etc/fstab的所有内容重新加载);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>[备份]磁盘阵列+备份盘</p>
<ul>
<li><p>RAID 10磁盘阵列中<strong>最多允许50%的硬盘设备发生故障</strong>，但是存在这样一种极端情况，<strong>即同一RAID 1磁盘阵列中的硬盘设备若全部损坏</strong>，也会导致数据丢失。换句话说，在RAID 10磁盘阵列中，如果RAID 1中的某一块硬盘出现了故障，而我们正在前往修复的路上，恰巧该RAID1磁盘阵列中的另一块硬盘设备也出现故障，那么数据就被彻底丢失了。</p>
<ul>
<li><p><strong>使用RAID5</strong></p>
<ul>
<li><p><strong>1.使用mdadm 命令创建RAID5阵列</strong></p>
<p>  现在创建一个RAID 5磁盘阵列+备份盘。在下面的命令中，参数-n 3代表创建这个RAID 5磁盘阵列所需的硬盘数，参数-l 5代表RAID的级别，而参数-x 1则代表有一块备份盘。当查看/dev/md0（即RAID 5磁盘阵列的名称）磁盘阵列的时候就能看到有一块备份盘在等待中了。</p>
<ul>
<li><p>命令:mdadm -Cv /dev/md0 -n 3 -l 5 -x 1 /dev/sdb /dev/sdc /dev/sdd /dev/sde</p>
<ul>
<li><p><strong>其中 -x 1 代表有一块备份盘</strong></p>
</li>
<li><p>命令实例代码</p>
<p>  [root@linuxprobe ~]# mdadm -Cv /dev/md0 -n 3 -l 5 -x 1 /dev/sdb /dev/sdc /dev/sdd /dev/sde<br>  mdadm: layout defaults to left-symmetric<br>  mdadm: layout defaults to left-symmetric<br>  mdadm: chunk size defaults to 512K<br>  mdadm: size set to 20954624K<br>  mdadm: Defaulting to version 1.2 metadata<br>  mdadm: array /dev/md0 started.<br>  [root@linuxprobe ~]# mdadm -D /dev/md0<br>  /dev/md0:<br>  Version : 1.2<br>  Creation Time : Fri May 8 09:20:35 2017<br>  Raid Level : raid5<br>  Array Size : 41909248 (39.97 GiB 42.92 GB)<br>  Used Dev Size : 20954624 (19.98 GiB 21.46 GB)<br>  Raid Devices : 3<br>  Total Devices : 4<br>  Persistence : Superblock is persistent<br>  Update Time : Fri May 8 09:22:22 2017<br>  State : clean<br>  Active Devices : 3<br>  Working Devices : 4<br>  Failed Devices : 0<br>  Spare Devices : 1<br>  Layout : left-symmetric<br>  Chunk Size : 512K<br>  Name : linuxprobe.com:0 (local to host linuxprobe.com)<br>  UUID : 44b1a152:3f1809d3:1d234916:4ac70481<br>  Events : 18<br>  Number Major Minor RaidDevice State<br>  0 8 16 0 active sync /dev/sdb<br>  1 8 32 1 active sync /dev/sdc<br>  4 8 48 2 active sync /dev/sdd<br>  3 8 64 - spare /dev/sde</p>
</li>
<li><p>相比创建RAID10的时候多了 -x 1 少了 -a yes</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.将RAID 5格式化成ext4格式,然后挂在到目录上</p>
<ul>
<li><p>实例代码</p>
<p>  [root@linuxprobe ~]# mkfs.ext4 /dev/md0<br>  mke2fs 1.42.9 (28-Dec-2013)<br>  Filesystem label=<br>  OS type: Linux<br>  Block size=4096 (log=2)<br>  Fragment size=4096 (log=2)<br>  Stride=128 blocks, Stripe width=256 blocks<br>  2621440 inodes, 10477312 blocks<br>  523865 blocks (5.00%) reserved for the super user<br>  First data block=0<br>  Maximum filesystem blocks=2157969408<br>  320 block groups<br>  32768 blocks per group, 32768 fragments per group<br>  8192 inodes per group<br>  Superblock backups stored on blocks:<br>  32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,<br>  4096000, 7962624<br>  Allocating group tables: done<br>  Writing inode tables: done<br>  Creating journal (32768 blocks): done<br>  Writing superblocks and filesystem accounting information: done<br>  [root@linuxprobe ~]# echo “/dev/md0 /RAID ext4 defaults 0 0” &gt;&gt; /etc/fstab<br>  [root@linuxprobe ~]# mkdir /RAID<br>  [root@linuxprobe ~]# mount -a</p>
</li>
</ul>
</li>
<li><p><strong>3.最后测试将设备/dev/sdb移除磁盘阵列,就会发现备份盘已经被自动顶替上去并开始了数据同步</strong></p>
<ul>
<li><p><strong>实例代码</strong></p>
<p>  [root@linuxprobe ~]# mdadm /dev/md0 -f /dev/sdb<br>  mdadm: set /dev/sdb faulty in /dev/md0<br>  [root@linuxprobe ~]# mdadm -D /dev/md0<br>  /dev/md0:<br>  Version : 1.2<br>  Creation Time : Fri May 8 09:20:35 2017<br>  Raid Level : raid5<br>  Array Size : 41909248 (39.97 GiB 42.92 GB)<br>  Used Dev Size : 20954624 (19.98 GiB 21.46 GB)<br>  Raid Devices : 3<br>  Total Devices : 4<br>  Persistence : Superblock is persistent<br>  Update Time : Fri May 8 09:23:51 2017<br>  State : active, degraded, recovering<br>  Active Devices : 2<br>  Working Devices : 3<br>  Failed Devices : 1<br>  Spare Devices : 1<br>  Layout : left-symmetric<br>  Chunk Size : 512K<br>  Rebuild Status : 0% complete<br>  Name : linuxprobe.com:0 (local to host linuxprobe.com)<br>  UUID : 44b1a152:3f1809d3:1d234916:4ac70481<br>  Events : 21<br>  Number Major Minor RaidDevice State<br>  3 8 64 0 spare rebuilding /dev/sde<br>  1 8 32 1 active sync /dev/sdc<br>  4 8 48 2 active sync /dev/sdd<br>  0 8 16 - faulty /dev/sdb</p>
<ul>
<li><strong>square rebuilding(英文是备份重建的意思)</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>部署RAID 5磁盘阵列时，至少需要用到3块硬盘，还需要再加一块备份硬盘，所以总计需要在虚拟机中模拟4块硬盘设备</p>
</li>
</ul>
</li>
<li><p>解决办法:准备一个备份盘随时替补上</p>
<p>  这块硬盘平时处于闲置状态，一旦RAID磁盘阵列中有硬盘出现故障后则会马上自动顶替上去。这样很棒吧！</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>LVM逻辑卷管理器</p>
<p>  前面学习的硬盘设备管理技术虽然能够有效地提高硬盘设备的读写速度以及数据的安全性，但是在硬盘分好区或者部署为RAID磁盘阵列之后，再想修改硬盘分区大小就不容易了。换句话说，当用户想要随着实际需求的变化调整硬盘分区的大小时，会受到硬盘“灵活性”的限制。这时就需要用到另外一项非常普及的硬盘设备资源管理技术了—LVM（逻辑卷管理器）。LVM可以允许用户对硬盘资源进行动态调整。</p>
<ul>
<li><p>LVM逻辑卷的概念</p>
<ul>
<li><p>LVM技术是在硬盘分区和文件系统之间添加了一个逻辑层，它提供了一个抽象的卷组，可以把多块硬盘进行卷组合并。这样一来，用户不必关心物理硬盘设备的底层架构和布局，就可以实现对硬盘分区的动态调整</p>
<ul>
<li><p>比喻:  </p>
<p>为了帮助大家理解，刘遄老师来举一个吃货的例子。比如小明家里想吃馒头但是面粉不够了，于是妈妈从隔壁老王家、老李家、老张家分别借来一些面粉，准备蒸馒头吃。首先需要把这些面粉（物理卷[PV，Physical Volume]）揉成一个大面团（卷组[VG，Volume Group]），然后再把这个大面团分割成一个个小馒头（逻辑卷[LV，Logical Volume]），而且每个小馒头的重量必须是每勺面粉（基本单元[PE，Physical Extent]）的倍数</p>
</li>
<li><p>核心理念:  </p>
<p><strong>物理卷处于LVM中的最底层，可以将其理解为物理硬盘</strong>、硬盘分区或者RAID磁盘阵列，这都可以。  <strong>卷组建立在物理卷之上</strong>，<strong>一个卷组可以包含多个物理卷</strong>，而且在卷组创建之后也可以继续向其中添加新的物理卷。  <strong>逻辑卷是用卷组中空闲的资源建立的，并且逻辑卷在建立后可以动态地扩展或缩小空间</strong>。这就是LVM的核心理念</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>部署逻辑卷</p>
<p>  一般而言，在生产环境中无法精确地评估每个硬盘分区在日后的使用情况，因此会导致原先分配的硬盘分区不够用。比如，伴随着业务量的增加，用于存放交易记录的数据库目录的体积也随之增加；因为分析并记录用户的行为从而导致日志目录的体积不断变大，这些都会导致原有的硬盘分区在使用上捉襟见肘。而且，还存在对较大的硬盘分区进行精简缩容的情况</p>
<ul>
<li><p>步骤:</p>
<ul>
<li><p>部署逻辑卷</p>
<ul>
<li><p>1.使用” pvcreate /dev/sdx “命令让硬盘支持LVM技术(/dev/sdx为硬盘设备文件)</p>
</li>
<li><p>2.使用” vgcreate 卷组名称 /dev/sdx”  命令将硬盘加入到name卷组中</p>
</li>
<li><p>3.使用” lvcreate -n vo -l 37 卷组名称 “命令切割出一个4M*37M大小的逻辑卷</p>
<ul>
<li><p>-n : 名称</p>
</li>
<li><p>-l : 大小(以及本单元为个数的单位,每个单元4M)</p>
</li>
<li><p>-L : 以容量M为单位</p>
</li>
</ul>
</li>
<li><p>4.格式化,使用mkfs.ext4 /dev/卷组名称/逻辑卷名称 将逻辑卷格式化为ext4格式</p>
<ul>
<li><p>4-1 创建目录并挂载 :<br> mkdir /挂载目录名 mount  /dev/卷组名称/逻辑卷名称   /挂载目录名</p>
</li>
<li><p>4-2 写入到配置文件使其永久生效:  </p>
<p>echo “/dev/卷组名称/逻辑卷名称   /挂载目录名  ext4 defaults 0 0” &gt;&gt; /etc/fstab</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>扩容和缩小逻辑卷</p>
<ul>
<li><p>扩容逻辑卷</p>
<ul>
<li><p>1.卸载设备和挂载点的关联: 命令 umount /挂载点</p>
</li>
<li><p>2.使用命令 <strong>lvextend</strong> -L 290M /dev/卷组名/逻辑卷名 将逻辑卷扩容到290M</p>
</li>
<li><p>3.检查硬盘完整性,并重置硬盘容量 :   </p>
<p>检查硬盘完整性命令: e2fsck -f /dev/storage/vo  </p>
<p>重置硬盘容量命令:<br>resize2fs /dev/卷组名/逻辑卷命名</p>
<ul>
<li><p>问题:</p>
<ul>
<li><p>resize2fs提示没有这个命令</p>
<ul>
<li>解决办法:再试一次就好了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>4.从新挂载设备并查看挂载状态:  重新挂载命令:<br>mount -a  </p>
<p>查看挂载状态命令:<br>df -h</p>
</li>
</ul>
</li>
<li><p>缩小逻辑卷</p>
<p>  相较于扩容逻辑卷，在对逻辑卷进行缩容操作时，其丢失数据的风险更大。所以在生产环境中执行相应操作时，一定要提前备份好数据。另外Linux系统规定，在对LVM逻辑卷进行缩容操作之前，要先检查文件系统的完整性（当然这也是为了保证我们的数据安全）。在执行缩容操作前记得先把文件系统卸载掉。</p>
<ul>
<li><p>1.卸载设备和挂载点的关联: 命令 umount /挂载点</p>
</li>
<li><p>2.检查硬盘完整性,并重置硬盘容量 :   </p>
<p>检查硬盘完整性命令: e2fsck -f /dev/storage/vo</p>
</li>
<li><p>3.使用命令 <strong>lvreduce</strong> -L 120M /dev/卷组名/逻辑卷名 将逻辑卷缩小到120M</p>
</li>
<li><p>4.从新挂载设备并查看挂载状态:  重新挂载命令:<br>mount -a  </p>
<p>查看挂载状态命令:<br>df -h</p>
<ul>
<li><p>问题:</p>
<ul>
<li><p>缩小后使用mount -a命令重新挂载提示mount:worng fs type , bad option , bad superblock on /dev/mapper/storage-vo</p>
<ul>
<li>解决办法:重新格式化逻辑卷(mkfs.ext4 /dev/卷组名/逻辑卷名)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Tips: 要备份,缩小风险比较大</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>逻辑卷快照</p>
<ul>
<li><p>1.使用命令 lvcreate -L 和逻辑卷一样大小的容量M -s -n 快照名称  /dev/卷组名/逻辑卷名称</p>
<ul>
<li><p>-s : 创建快照</p>
</li>
<li><p>-n : 快照路径和名称</p>
</li>
</ul>
</li>
<li><p>2.还原</p>
<ul>
<li><p>2-1.使用umount /逻辑卷挂载的目录 , 解除挂载</p>
</li>
<li><p>2-2.[还原] 使用命令 : lvconvert —merge /dev/卷组名/逻辑卷快照名 , 还原</p>
</li>
</ul>
</li>
<li><p>3.使用mount a 再次挂载</p>
</li>
<li><p><strong>注意: 快照卷的容量必须等同于逻辑卷的容量,快照卷仅一次有效,一旦执行还原操作后则会被立即自动删除</strong></p>
</li>
</ul>
</li>
<li><p>删除逻辑卷</p>
<ul>
<li><p><strong>删除顺序: 依次删除 逻辑卷 \ 卷组 \ 物理卷设备 (不可颠倒)<br>依次使用的命令是:<br>lvremove<br>vgremove<br>pvremove</strong></p>
</li>
<li><p>1.使用 umount /挂载目录 ,解除挂载</p>
</li>
<li><p>2.vim 进入 /etc/fstab 删除配置文件中永久生效的设备参数</p>
</li>
<li><p>3.使用命令 lvremove /dev/卷组名/逻辑卷名 , 删除逻辑卷</p>
</li>
<li><p>4.使用命令 vgremove 卷组名,删除卷组</p>
</li>
<li><p>5.使用命令 pvremove /dev/设备x ,删除物理设备</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>部署LVM:需要逐个配置物理卷\卷组和逻辑卷</p>
<ul>
<li><p><strong>部署命令<br>XXscan(扫描)<br>XXcreate(创建)<br>XXdisplay(显示)<br>XXremove(删除)<br>XXextend(扩展)<br>XXreduce(缩小)</strong></p>
<p>  常用的LVM部署命令<br>  功能/命令<br>  物理卷管理<br>  卷组管理<br>  逻辑卷管理<br>  扫描<br>  pvscan<br>  vgscan<br>  lvscan<br>  建立<br>  pvcreate<br>  vgcreate<br>  lvcreate<br>  显示<br>  pvdisplay<br>  vgdisplay<br>  lvdisplay<br>  删除<br>  pvremove<br>  vgremove<br>  lvremove<br>  扩展  </p>
<p>  vgextend<br>  lvextend<br>  缩小  </p>
<p>  vgreduce<br>  lvreduce</p>
<ul>
<li><p>pv打头是物理卷</p>
<ul>
<li>没有扩展和缩小命令</li>
</ul>
</li>
<li><p>vg打头是卷组</p>
</li>
<li><p>lv打头是逻辑卷</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>自己当前的理解:LVM就是不分区,假装软分区</p>
</li>
</ul>
</li>
</ul>
<h3 id="第八章-iptables-与-Firewalld-防火墙"><a href="#第八章-iptables-与-Firewalld-防火墙" class="headerlink" title="第八章 iptables 与 Firewalld 防火墙"></a>第八章 iptables 与 Firewalld 防火墙</h3><p>保障数据的安全性是继保障数据的可用性之后最为重要的一项工作。防火墙作为公网与内网之间的保护屏障，在保障数据的安全性方面起着至关重要的作用  </p>
<p>本章将分别使用iptables、firewall-cmd、firewall-config和TCP Wrappers等防火墙策略配置服务来完成数十个根据真实工作需求而设计的防火墙策略配置实验。在学习完这些实验之后，各位读者不仅可以熟练地过滤请求的流量，还可以基于服务程序的名称对流量进行允许和拒绝操作</p>
<p>**本章目录结构 [<a href="https://www.linuxprobe.com/chapter-08.html#" target="_blank" rel="noopener">收起</a>]<br>        <a href="https://www.linuxprobe.com/chapter-08.html#81" target="_blank" rel="noopener">8.1 防火墙管理工具</a><br>        <a href="https://www.linuxprobe.com/chapter-08.html#82_Iptables" target="_blank" rel="noopener">8.2 Iptables</a><br>        <a href="https://www.linuxprobe.com/chapter-08.html#821" target="_blank" rel="noopener">8.2.1 策略与规则链</a><br>        <a href="https://www.linuxprobe.com/chapter-08.html#822" target="_blank" rel="noopener">8.2.2 基本的命令参数</a><br>        <a href="https://www.linuxprobe.com/chapter-08.html#83_Firewalld" target="_blank" rel="noopener">8.3 Firewalld</a><br>        <a href="https://www.linuxprobe.com/chapter-08.html#831" target="_blank" rel="noopener">8.3.1 终端管理工具</a><br>        <a href="https://www.linuxprobe.com/chapter-08.html#832" target="_blank" rel="noopener">8.3.2 图形管理工具</a><br>        <a href="https://www.linuxprobe.com/chapter-08.html#84" target="_blank" rel="noopener">8.4 服务的访问控制列表</a></p>
<ul>
<li><p>8.1 防火墙管理工具</p>
<p>  防火墙策略可以基于流量的源目地址、端口号、协议、应用等信息来定制，然后防火墙使用预先定制的策略规则监控出入的流量，若流量与某一条策略规则相匹配，则执行相应的处理，反之则丢弃。这样一来，就可以保证仅有合法的流量在企业内网和外部公网之间流动了。  </p>
<p>  在RHEL 7系统中，firewalld防火墙取代了iptables防火墙,iptables与firewalld都不是真正的防火墙，它们都只是用来定义防火墙策略的防火墙管理工具而已.</p>
<p>  iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理</p>
</li>
<li><p>8.2 Iptables</p>
<p>  尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables</p>
<p>  iptables是一款基于<a href="https://www.linuxcool.com/" target="_blank" rel="noopener">命令</a>行的防火墙策略管理工具，具有大量参数，学习难度较大。好在对于日常的防火墙策略配置来讲，大家无需深入了解诸如“四表五链”的理论概念，只需要掌握常用的参数并做到灵活搭配即可，这就足以应对日常工作了。</p>
<ul>
<li><p>8.2.1 策略与规则链</p>
<p>  iptables命令可以根据流量的源地址、目的地址、传输协议、服务类型等信息进行匹配，一旦匹配成功，iptables就会根据策略规则所预设的动作来处理这些流量</p>
<ul>
<li><p>防火墙的规则与描述</p>
<p>  <strong>防火墙会从上至下的顺序来读取配置的策略规则</strong>，<strong>在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略</strong>。</p>
<p>  一般而言，<strong>防火墙策略规则的设置有两种</strong>：一种是“通”（即放行），一种是“堵”（即阻止）。当防火墙的默认策略为拒绝时（堵），就要设置允许规则（通），否则谁都进不来；如果防火墙的默认策略为允许时，就要设置拒绝规则，否则谁都能进来，防火墙也就失去了防范的作用。</p>
<p>  <strong>iptables服务把用于处理或过滤流量的策略条目称之为规则</strong></p>
<ul>
<li><p>iptables服务把用于处理或过滤流量的策略条目称之为规则,<strong>多条规则可以组成一个规则链</strong>，而规则链则依据数据包处理位置的<strong>不同进行分类</strong>，具体如下</p>
<p>  在进行路由选择前处理数据包（PREROUTING）；</p>
<p>  处理流入的数据包（INPUT）；</p>
<p>  处理流出的数据包（OUTPUT）；</p>
<p>  处理转发的数据包（FORWARD）；</p>
<p>  在进行路由选择后处理数据包（POSTROUTING）;</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>            一般来说，从内网向外网发送的流量一般都是可控且良性的，因此我们使用最多的就是INPUT规则链，该规则链可以增大黑客人员从外网入侵内网的难度。

            - iptables术语

                - ACCEPT : 允许流量通过

                - REJECT : 拒绝流量通过

                - LOG : 记录日志信息

                - DROP : 拒绝流量通过

                - REJECT 和 DROP 不同点

                    - REJECT : 会在拒绝流量后再恢复一条”您的信息已经收到,但是被扔掉了”信息,从而让流量发送方清晰地看到数据被拒绝相应的信息

                        - 例子

                            当把Linux系统中的防火墙策略设置为REJECT拒绝动作后，流量发送方会看到端口不可达的响应：
                            [root@linuxprobe ~]# ping -c 4 192.168.10.10  
                            PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.  
                            From 192.168.10.10 icmp_seq=1 Destination Port Unreachable  
                            From 192.168.10.10 icmp_seq=2 Destination Port Unreachable  
                            From 192.168.10.10 icmp_seq=3 Destination Port Unreachable  
                            From 192.168.10.10 icmp_seq=4 Destination Port Unreachable  
                            --- 192.168.10.10 ping statistics ---  
                            4 packets transmitted, 0 received, +4 errors, 100% packet loss, time 3002ms

                    - DROP : 直接将流浪丢弃而不响应

                        - 例子

                            而把Linux系统中的防火墙策略修改成DROP拒绝动作后，流量发送方会看到响应超时的提醒。但是流量发送方无法判断流量是被拒绝，还是接收方主机当前不在线：
                            [root@linuxprobe ~]# ping -c 4 192.168.10.10  
                            PING 192.168.10.10 (192.168.10.10) 56(84) bytes of data.  

                            --- 192.168.10.10 ping statistics ---  
                            4 packets transmitted, 0 received, 100% packet loss, time 3000ms

                    - 比喻

                        我们来举一个例子，让各位读者更直观地理解这两个拒绝动作的不同之处。比如有一天您正在家里看电视，突然听到有人敲门，您透过防盗门的猫眼一看是推销商品的，便会在不需要的情况下开门并拒绝他们（REJECT）。但如果您看到的是债主带了十几个小弟来讨债，此时不仅要拒绝开门，还要默不作声，伪装成自己不在家的样子（DROP）

            - 比喻

                比如在您居住的社区内，物业管理公司有两条规定：禁止小商小贩进入社区；各种车辆在进入社区时都要登记。显而易见，这两条规定应该是用于社区的正门的（流量必须经过的地方），而不是每家每户的防盗门上。根据前面提到的防火墙策略的匹配顺序，可能会存在多种情况。比如，来访人员是小商小贩，则直接会被物业公司的保安拒之门外，也就无需再对车辆进行登记。如果来访人员乘坐一辆汽车进入社区正门，则“禁止小商小贩进入社区”的第一条规则就没有被匹配到，因此按照顺序匹配第二条策略，即需要对车辆进行登记。如果是社区居民要进入正门，则这两条规定都不会匹配到，因此会执行默认的放行策略。

                但是，仅有策略规则还不能保证社区的安全，保安还应该知道采用什么样的动作来处理这些匹配的流量，比如“允许”、“拒绝”、“登记”、“不理它”。这些动作对应到iptables服务的术语中分别是ACCEPT（允许流量通过）、REJECT（拒绝流量通过）、LOG（记录日志信息）、DROP（拒绝流量通过）。“允许流量通过”和“记录日志信息”都比较好理解，这里需要着重讲解的是REJECT和DROP的不同点。就DROP来说，它是直接将流量丢弃而且不响应；REJECT则会在拒绝流量后再回复一条“您的信息已经收到，但是被扔掉了”信息，从而让流量发送方清晰地看到数据被拒绝的响应信息。

- 8.2.2 基本的命令参数

    - 常用iptables命令参数

        - -P : 设置默认策略

            - POLICY : 策略方针

        - -F    清空规则链

            - Flush

        - -L    查看规则链

            - List : 清单

        - -A    在规则链的末尾加入新规则

            - APPEND : 附加

        - -I num    在规则链的头部加入新规则

            - INSERT : 插入

        - -D num    删除某一条规则

            - DELETE : 删除

        - -s    匹配来源地址IP/MASK，加叹号“!”表示除这个IP外

            - SORUCE : 源地址

        - -d    匹配目标地址

            - DESTINATION : 目的地

        - -i 网卡名称    匹配从这块网卡流入的数据

            - INPUT : 输出

        - -o 网卡名称    匹配从这块网卡流出的数据

            - OUTPUT : 进入

        - -p    匹配协议，如TCP、UDP、ICMP

            - Protocol : 协议

        - --dport num    匹配目标端口号

            - DESTINATION PORT : 目的端口

        - --sport num    匹配来源端口号

            - SOURCE PORT : 源端口

        - -j 指定当”匹配条件”满足时,所对应的操作

        - 详细解释参考

            网页1:
            [http://cnzhx.net/blog/common-iptables-cli/#2a](http://cnzhx.net/blog/common-iptables-cli/#2a)

            网页2:  
            [http://www.zsythink.net/archives/1199/](http://www.zsythink.net/archives/1199/)
            [http://www.zsythink.net/archives/1517](http://www.zsythink.net/archives/1517)

- 实例

    - **在iptables命令后添加-L参数查看已有的防火墙规则链：**

        - iptables -L

    - **在iptables命令后添加-F参数清空已有的防火墙规则链**

        - iptables -F  
          iptables -L

    - **把INPUT规则链的默认策略设置为拒绝**

        - iptables -P INPUT DROP  
          iptables -L

    - **向INPUT链中添加允许ICMP流量进入的策略规则  :**  向防火墙的INPUT规则链中添加一条允许ICMP流量进入的策略

        在日常运维工作中，经常会使用ping命令来检查对方主机是否在线，而向防火墙的INPUT规则链中添加一条允许ICMP流量进入的策略规则就默认允许了这种ping命令检测行为。

        - iptables -I INPUT -p icmp -j ACCEPT

    - **删除INPUT规则链中刚刚加入的那条策略（允许ICMP流量），并把默认策略设置为允许**

        - iptables -D INPUT 1  
          iptables -P INPUT ACCEPT  
          iptables -L

    - **将INPUT规则链设置为只允许指定网段的主机访问本机的22端口，拒绝来自其他所有主机的流量**

        - iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT  

          iptables -A INPUT -p tcp --dport 22 -j REJECT

    - **向INPUT规则链中添加拒绝所有人访问本机12345端口的策略规则**

        - iptables -I INPUT -p tcp --dport 12345 -j REJECT  

          iptables -I INPUT -p udp --dport 12345 -j REJECT

    - **向INPUT规则链中添加拒绝192.168.10.5主机访问本机80端口（Web服务）的策略规则**

        - iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT

    - **向INPUT规则链中添加拒绝所有主机访问本机1000**～**1024端口的策略规则**

        - iptables -A INPUT -p tcp --dport 1000:1024 -j REJECT  

          iptables -A INPUT -p udp --dport 1000:1024 -j REJECT

    - **最后别忘了保存**

        - service iptables save

    - **总结: 大概代码框架** iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT

        - **大部分时间都有的代码**

            - **-I INPUT** 

            - **-p tcp**

            - **-s iP地址**

                - **限制特定ip地址时就用**

            - **—dport 端口号**

                - **有端口号时就用**

            - **-j REJECT或APPECT**

- 

    - **总结**

        - **iptables的常用命令**

            大写:

            PFLAID  

            P设 F清 L查  A加尾 I加头 D删  

            小写:  

            sdiop 

            匹配  

            s来源IP  d目标IP  i网卡流入数据 o网卡流出数据 p协议TCP\UDP\ICMP  

            两个词组  

            —dport    —sport  

            目标端口    来源端口

        - **注意事项**

            防火墙是从上至下匹配的  

            允许的动作要放到拒绝的前面  

            设置完记得使用 service iptables save 保存设置!</code></pre><ul>
<li><p>8.3 Firewalld(RHEL 7默认防火墙)</p>
<p>  RHEL 7系统中集成了多款防火墙管理工具，其中firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器）服务是默认的防火墙配置管理工具，它拥有基于CLI（命令行界面）和基于GUI（图形用户界面）的两种管理方式</p>
<ul>
<li><p>8.3.1 终端管理工具(CLI)</p>
<p>  firewall-cmd是firewalld防火墙配置管理工具的CLI（命令行界面）版本。它的参数一般都是以“长格式”来提供的，大家不要一听到长格式就头大，因为RHEL 7系统支持部分命令的参数补齐，其中就包含这条命令（很酷吧）。也就是说，现在除了能用Tab键自动补齐命令或文件名等内容之外</p>
<ul>
<li><p>Permanent与Runtime模式</p>
<p>  与Linux系统中其他的防火墙策略配置工具一样，使用firewalld配置的防火墙策略默认为运行时（Runtime）模式，又称为当前生效模式，而且随着系统的重启会失效。</p>
<p>  如果想让配置策略一直存在，<strong>就需要使用永久（Permanent）模式了，方法就是在用firewall-cmd命令正常设置防火墙策略时添加–permanent参数</strong>，这样配置的防火墙策略就可以永久生效了。</p>
<p>  但是，永久生效模式有一个“不近人情”的特点，就是使用它设置的策略只有在系统重启之后才能自动生效。<strong>如果想让配置的策略立即生效，需要手动执行firewall-cmd –reload命令。</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>        总结**:**

        **当前模式与永久模式是分开的两种模式**

        - Permanent模式

            - 设置策略时候添加—permanent参数

                - **但这样必须重启才生效,要想立即生效需要手动执行 : firewall-cmd —reload 命令**

    - firewall-cmd 命令中使用的参数以及作用,使用方法: firewall-cmd [参数]

        - --get-default-zone    查询默认的区域名称

        - --set-default-zone=&lt;区域名称&gt;    设置默认的区域，使其永久生效

        - --get-zones    显示可用的区域

        - --get-services    显示预先定义的服务

        - --get-active-zones    显示当前正在使用的区域与网卡名称

        - --add-source=    将源自此IP或子网的流量导向指定的区域

        - --remove-source=    不再将源自此IP或子网的流量导向某个指定区域

        - --add-interface=&lt;网卡名称&gt;    将源自该网卡的所有流量都导向某个指定区域

        - --change-interface=&lt;网卡名称&gt;    将某个网卡与区域进行关联

        - —get-zone-of-interface=&lt;网卡名称&gt;  查询这个网卡在firewalld服务中的区域

        - --list-all    显示当前区域的网卡配置参数、资源、端口以及服务等信息

        - --list-all-zones    显示所有区域的网卡配置参数、资源、端口以及服务等信息

        - --add-service=&lt;服务名&gt;    设置默认区域允许该服务的流量

        - --add-port=&lt;端口号/协议&gt;    设置默认区域允许该端口的流量

        - --remove-service=&lt;服务名&gt;    设置默认区域不再允许该服务的流量

        - --remove-port=&lt;端口号/协议&gt;    设置默认区域不再允许该端口的流量

        - --reload    让“永久生效”的配置规则立即生效，并覆盖当前的配置规则

        - --panic-on    开启应急状况模式

        - --panic-off    关闭应急状况模式

        - —zone=public —query-service=ssh或https   查询public区域示范允许请求SSH和HTTPS协议的流量

- 8.3.2 图形管理工具(GUI)

    可以实现所有以命令行来执行的操作。毫不夸张的说，即使读者没有扎实的Linux命令基础，也完全可以通过它来妥善配置RHEL 7中的防火墙策略。firewall-config的界面

    - SNAT技术（（Source Network Address Translation，源网络地址转换）

        大家可以看一下在网络中不使用SNAT技术（见图8-6）和使用SNAT技术（见图8-7）时的情况。在图8-6所示的局域网中有多台PC，如果网关服务器没有应用SNAT技术，则互联网中的网站服务器在收到PC的请求数据包，并回送响应数据包时，将无法在网络中找到这个私有网络的IP地址，所以PC也就收不到响应数据包了。在图8-7所示的局域网中，由于网关服务器应用了SNAT技术，所以互联网中的网站服务器会将响应数据包发给网关服务器，再由后者转发给局域网中的PC。


        图片1:没有使用SNAT技术的网络  

        https://www.linuxprobe.com/wp-content/uploads/2015/03/%E6%9C%AA%E7%94%A8SNAT1.png  

        图片2:使用SNAT技术处理过的网络  

        https://www.linuxprobe.com/wp-content/uploads/2015/03/%E4%BD%BF%E7%94%A8SNAT1.png

        - 在Firewall-config（图形界面中设置SNAP）

            在Zone下的左边栏Zone选中要修改的区域模板，然后再选择右边栏的Masquerading，勾选Masquerade Zone就可以了！

    - 功能

        **1：**选择运行时（Runtime）模式或永久（Permanent）模式的配置。
        **2**：可选的策略集合区域列表。
        **3**：常用的系统服务列表。
        **4**：当前正在使用的区域。
        **5**：管理当前被选中区域中的服务。
        **6**：管理当前被选中区域中的端口。
        **7**：开启或关闭SNAT（源地址转换协议）技术。
        **8**：设置端口转发策略。
        **9**：控制请求icmp服务的流量。
        **10**：管理防火墙的富规则。
        **11**：管理网卡设备。
        **12**：被选中区域的服务，若勾选了相应服务前面的复选框，则表示允许与之相关的流量。
        **13**：firewall-config工具的运行状态。

        对应的图片：  

        https://www.linuxprobe.com/wp-content/uploads/2015/03/firewall-config%E7%95%8C%E9%9D%A2.png

- 8.4 TCP Wrappers 服务的访问控制列表

    TCP Wrappers是RHEL 7系统中默认启用的一款流量监控程序，它能够根据来访主机的地址与本机的目标服务程序作出允许或拒绝的操作。换句话说，Linux系统中其实有两个层面的防火墙，第一种是前面讲到的基于TCP/IP协议的流量过滤工具，而TCP Wrappers服务则是能允许或禁止Linux系统提供服务的防火墙，从而在更高层面保护了Linux系统的安全运行。


    TCP Wrappers服务的防火墙策略由两个控制列表文件所控制，用户可以编辑允许控制列表文件来放行对服务的请求流量，也可以编辑拒绝控制列表文件来阻止对服务的请求流量。控制列表文件修改后会立即生效，系统将会先检查允许控制列表文件（/etc/hosts.allow），如果匹配到相应的允许策略则放行流量；如果没有匹配，则去进一步匹配拒绝控制列表文件（/etc/hosts.deny），若找到匹配项则拒绝该流量。如果这两个文件全都没有匹配到，则默认放行流量。

    - 允许控制列表文件：/etc/hosts.allow

    - 拒绝控制列表文件:/etc/hosts.deny

    - TCP Wrappers服务的控制列表文件中常用的参数

        单一主机  
        192.168.10.10  
        IP地址为192.168.10.10的主机
        指定网段  
        192.168.10.  
        IP段为192.168.10.0/24的主机
        指定网段  
        192.168.10.0/255.255.255.0  
        IP段为192.168.10.0/24的主机
        指定DNS后缀
        .linuxprobe.com  
        所有DNS后缀为.linuxprobe.com的主机
        指定主机名称  
        www.linuxprobe.com  
        主机名称为www.linuxprobe.com的主机
        指定所有客户端  
        ALL  
        所有主机全部包括在内

    - 配置TCP Wrappers服务遵循两个原则

        - 1.编写拒绝策略规则时,填写的是服务名称而非协议名称

        - 2.建议先编写拒绝策略规则,再编写允许策略规则,以便直观的看到相应效果

    - 例子

        - 1.编写拒绝策略文件:禁止访问本机sshd服务的所有流量(无需在/etc/hosts.deny中修改原有注释信息)

            - 例子

                [root@linuxprobe ~]# vim /etc/hosts.deny  
                #  
                # hosts.deny This file contains access rules which are used to  
                # deny connections to network services that either use  
                # the tcp_wrappers library or that have been  
                # started through a tcp_wrappers-enabled xinetd.  
                #  
                # The rules in this file can also be set up in  
                # /etc/hosts.allow with a &apos;deny&apos; option instead.  
                #  
                # See &apos;man 5 hosts_options&apos; and &apos;man 5 hosts_access&apos;  
                # for information on rule syntax.  
                # See &apos;man tcpd&apos; for information on tcp_wrappers  
                sshd:*  
                [root@linuxprobe ~]# ssh 192.168.10.10  
                ssh_exchange_identification: read: Connection reset by peer

        - 2.允许放行来自192.168.10.0/24网段访问本机sshd服务的所有流量(/etc/hosts.allow)

            - 例子代码

                [root@linuxprobe ~]# vim /etc/hosts.allow  
                #  
                # hosts.allow This file contains access rules which are used to  
                # allow or deny connections to network services that  
                # either use the tcp_wrappers library or that have been  
                # started through a tcp_wrappers-enabled xinetd.  
                #  
                # See &apos;man 5 hosts_options&apos; and &apos;man 5 hosts_access&apos;  
                # for information on rule syntax.  
                # See &apos;man tcpd&apos; for information on tcp_wrappers  
                sshd:192.168.10.  

                [root@linuxprobe ~]# ssh 192.168.10.10  
                The authenticity of host &apos;192.168.10.10 (192.168.10.10)&apos; can&apos;t be established.  
                ECDSA key fingerprint is 70:3b:5d:37:96:7b:2e:a5:28:0d:7e:dc:47:6a:fe:5c.  
                Are you sure you want to continue connecting (yes/no)? yes  
                Warning: Permanently added &apos;192.168.10.10&apos; (ECDSA) to the list of known hosts.  
                root@192.168.10.10&apos;s password:   
                Last login: Wed May 4 07:56:29 2017  
                [root@linuxprobe ~]# 

        - 例如:设置禁止所有流量访问sshd服务: 在etc/hosts.deny文件中添加sshd:*即可

- 与传统防火墙不同的地方

    相较于传统的防火墙管理配置工具，firewalld支持动态更新技术并加入了区域（zone）的概念。简单来说，区域就是firewalld预先准备了几套防火墙策略集合（策略模板），用户可以根据生产场景的不同而选择合适的策略集合，从而实现防火墙策略之间的快速切换。例如，我们有一台笔记本电脑，每天都要在办公室、咖啡厅和家里使用。按常理来讲，这三者的安全性按照由高到低的顺序来排列，应该是家庭、公司办公室、咖啡厅。当前，我们希望为这台笔记本电脑指定如下防火墙策略规则：在家中允许访问所有服务；在办公室内仅允许访问文件共享服务；在咖啡厅仅允许上网浏览。在以往，我们需要频繁地手动设置防火墙策略规则，而现在只需要预设好区域集合，然后只需轻点鼠标就可以自动切换了，从而极大地提升了防火墙策略的应用效率。**firewalld中常见的区域名称（默认为public）**以及相应的策略规则如表8-2所示。

- 默认规则策略

    - trusted  :  允许所有数据包 home  :  拒绝流入的流量,除非与出的流量相关;如果流量与SSH\mdns\ipp-client\amba-client与dhcpv6-client服务相关,则允许流量  
      internal  :  等同于Home区域  
      work  :  拒绝流入的流量,除非与流出的流量相关;如果流量与SSH\ipp-client与dhpv6-client服务相关,则允许流量  
      public  :  拒绝流入的流量,除非与流出的流量相关;如果流量与SSH\dhpv6-client服务相关,则允许流量
      external  :  拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量
      dmz  :  拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量
      block  :  拒绝流入的流量，除非与流出的流量相关
      drop  :  拒绝流入的流量，除非与流出的流量相关

        - **总结:**  
          前半句都是:  拒绝流入的流量,除非与流出的流量相关 - 这是必备条件
          后半句是允许的服务(与流出的流量相关) :  SSH\mdns\ipp-client\amba-client与dhcpv6-client等</code></pre><ul>
<li><p>8.4 服务的访问控制列表</p>
</li>
<li><p>其他内容</p>
<ul>
<li><p>问题与解决</p>
<ul>
<li><p>ICMP是什么?</p>
<ul>
<li><p>ICMP ( Internet Control Message Protocol) Internet控制报文协议</p>
<p>  它是<a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE%E7%B0%87" target="_blank" rel="noopener">TCP/IP协议簇</a>的一个子协议，用于在IP<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151" target="_blank" rel="noopener">主机</a>、<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">路由</a>器之间传递控制消息。控制消息是指<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A" target="_blank" rel="noopener">网络通</a>不通、<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151" target="_blank" rel="noopener">主机</a>是否可达、<a href="https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1/363497" target="_blank" rel="noopener">路由</a>是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。 [1]<br>  ICMP使用IP的基本支持，就像它是一个更高级别的协议，但是，ICMP实际上是IP的一个组成部分，必须由每个IP模块实现。 [2]</p>
<ul>
<li><p>参考</p>
<p>  百度百科:<br>  <a href="https://baike.baidu.com/item/ICMP/572452?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/ICMP/572452?fr=aladdin</a></p>
<p>  其他:</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP与UDP的区别</p>
<ul>
<li><p>TCP 慢,效率低,丢包少   |   UDP 快,不可靠,不稳定</p>
<ul>
<li><p>参考</p>
<p>  <a href="https://www.cnblogs.com/williamjie/p/9390164.html" target="_blank" rel="noopener">https://www.cnblogs.com/williamjie/p/9390164.html</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><p>TCP、UDP、ICMP、IGMP的解释和区别</p>
<p>  TCP与UDP解释<br>  TCP—传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。<br>  UDP—用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。<br>   TCP与UDP的区别：<br>  1、基于连接与无连接<br>  2、对系统资源的要求（TCP较多，UDP少）<br>  3、UDP程序结构较简单<br>  4、流模式与数据报模式<br>  5、TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证<br>   ICMP（Internet 控制消息协议，Internet Control Message Protocol）协议用来给IP协议提供控制服务，允许路由器或目标主机给数据的发送方提供反馈信息。需要发送反馈信息的情况包括：数据包不能被发送到 目标主机，路由器缓冲区溢出导致数据包被删除，路由器想要把流量重定向到另外一个更短的路由上等。ICMP协议是IP协议的一部分，任何实现了IP协议的 设备同时也被要求实现ICMP协议。<br>  <em>IGMP</em>（互联网组管理协议）是一种互联网协议，提供这样一种方法， 使得互联网上的主机向临近路由器报告它的广播组成员。 广播使得互联网上的一个主机向网上确认对于源主机发送内容感兴趣的计算机发送信息。<br>  IGMP(Internet Group Message Protocol):Internet组管理协议,提供internet网际多点传送的功能,即将一个ip包拷贝给多个host,windows系列采用 了这个协议,因为此项技术尚不成熟,因此被一些人用来攻击windows系统,尤其是对win98,因为对win95有oob攻击.<br>  用户数据报协议（UDP）是 ISO 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。 UDP 协议基本上是 IP 协议与上层协议的接口。 UDP 协议适用端口分辨运行在同一台设备上的多个应用程序</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>        参考文章:
        [https://www.cnblogs.com/nlxx/p/9922822.html](https://www.cnblogs.com/nlxx/p/9922822.html)

- 除了网络层还有什么层?

- 192.168.10.0/24最后的/24是什么意思?

- 12345端口是什么?</code></pre><h3 id="第九章-使用SSH服务管理远程主机"><a href="#第九章-使用SSH服务管理远程主机" class="headerlink" title="第九章 使用SSH服务管理远程主机"></a>第九章 使用SSH服务管理远程主机</h3><p>**本章目录结构 [<a href="https://www.linuxprobe.com/chapter-09.html#" target="_blank" rel="noopener">收起</a>]<br>        <a href="https://www.linuxprobe.com/chapter-09.html#91" target="_blank" rel="noopener">9.1 配置网卡服务</a><br>        <a href="https://www.linuxprobe.com/chapter-09.html#911" target="_blank" rel="noopener">9.1.1 配置网卡参数</a><br>        <a href="https://www.linuxprobe.com/chapter-09.html#912" target="_blank" rel="noopener">9.1.2 创建网络会话</a><br>        <a href="https://www.linuxprobe.com/chapter-09.html#913" target="_blank" rel="noopener">9.1.3 绑定两块网卡</a><br>        <a href="https://www.linuxprobe.com/chapter-09.html#92" target="_blank" rel="noopener">9.2 远程控制服务</a><br>        <a href="https://www.linuxprobe.com/chapter-09.html#921_sshd" target="_blank" rel="noopener">9.2.1 配置sshd服务</a><br>        <a href="https://www.linuxprobe.com/chapter-09.html#922" target="_blank" rel="noopener">9.2.2 安全密钥验证</a><br>        <a href="https://www.linuxprobe.com/chapter-09.html#923" target="_blank" rel="noopener">9.2.3 远程传输命令</a><br>        <a href="https://www.linuxprobe.com/chapter-09.html#93" target="_blank" rel="noopener">9.3 不间断会话服务</a><br>        <a href="https://www.linuxprobe.com/chapter-09.html#931" target="_blank" rel="noopener">9.3.1 管理远程会话</a><br>        <a href="https://www.linuxprobe.com/chapter-09.html#932" target="_blank" rel="noopener">9.3.2 会话共享功能</a></p>
<ul>
<li><p>9.1 网卡配置服务</p>
<ul>
<li><p>配置网卡参数</p>
<ul>
<li><p>命令:nmtui</p>
</li>
<li><p>步骤</p>
<ol>
<li><p>命令行输入nmtui命令  </p>
</li>
<li><p>选择Edit a connection回车  </p>
</li>
<li><p>选择网卡,再选择Edit编辑  </p>
</li>
<li><p>把网络iPv4的配置方式改成Manual(手动)  </p>
</li>
<li><p>按下Show(显示)按钮,显示信息配置框  </p>
</li>
<li><p>在服务器主机的网络配置信息中填写IP地址(Addresses) :192.168.10.10/24</p>
</li>
<li><p>点击OK保存  </p>
</li>
<li><p>点击Quit退出  </p>
</li>
<li><p>命令 systemctl restart network重启服务</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>9.2 创建网络会话</p>
<p>  通过命令nmcli管理Network Manager</p>
<ul>
<li><p>命令:nmcli</p>
<ul>
<li><p>命令:nmcli connection show 显示网络信息</p>
</li>
<li><p>网络会话服务(类似Firewalld的形式管理网络)</p>
<p>  RHEL7系统支持网络会话功能，允许用户在多个配置文件中快速切换（非常类似于firewalld防火墙服务中的区域技术）。如果我们在公司网络中使用笔记本电脑时需要手动指定网络的IP地址，而回到家中则是使用DHCP自动分配IP地址。这就需要麻烦地频繁修改IP地址，但是使用了网络会话功能后一切就简单多了—只需在不同的使用环境中激活相应的网络会话，就可以实现网络配置信息的自动切换了。</p>
<ul>
<li><p>命令格式: connection add con-name type ifname</p>
<ul>
<li><p>设置conpany(公司网络)</p>
<p>  可以使用nmcli命令并按照“connection add con-name type ifname”的格式来创建网络会话。假设将公司网络中的网络会话称之为company，将家庭网络中的网络会话称之为house，现在依次创建各自的网络会话。</p>
<p>  使用con-name参数指定公司所使用的网络会话名称company，然后依次用ifname参数指定本机的网卡名称（千万要以实际环境为准，不要照抄书上的eno16777736），用autoconnect no参数设置该网络会话默认不被自动激活，以及用ip4及gw4参数手动指定网络的IP地址</p>
<ul>
<li>nmcli connection add con-name 公司 ifname 网卡名称 autoconnect no type ethernet ip4 192.168.10.10/24 gw4 192.169.10.1</li>
</ul>
</li>
<li><p>设置house(家庭网络)</p>
<ul>
<li>nmcli connection add con-name 家庭 type ethernet ifname 网卡名称</li>
</ul>
</li>
<li><p>查看创建的所有网络会话</p>
<ul>
<li>nmcli connection show</li>
</ul>
</li>
<li><p>切换网络会话</p>
<ul>
<li>nmcli connection up company或house</li>
</ul>
</li>
<li><p>备注:如果是虚拟机请把网卡切换成桥接模式</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>9.1.3 绑定两块网卡</p>
<p>  一般来讲，生产环境必须提供7×24小时的网络传输服务。借助于网卡绑定技术，不仅可以提高网络传输速度，更重要的是，还可以确保在其中一块网卡出现故障时，依然可以正常提供网络服务。假设我们对两块网卡实施了绑定技术，这样在正常工作中它们会共同传输数据，使得网络传输的速度变得更快；而且即使有一块网卡突然出现了故障，另外一块网卡便会立即自动顶替上去，保证数据传输不会中断。</p>
<ul>
<li><p>步骤</p>
<ul>
<li><p>1.在虚拟机中添加一块网卡设备,确保两块网卡都处在同一网络连接中(即网卡模式相同)处于相同模式的网卡设备才可以进行网卡绑定,否则这两块网卡无法互相传送数据</p>
</li>
<li><p>2.使用Vim编辑网卡设备绑定参数</p>
<p>  网卡绑定的理论知识类似于前面学习的RAID硬盘组，我们需要对参与绑定的网卡设备逐个进行“初始设置”。<strong>需要注意的是，这些原本独立的网卡设备此时需要被配置成为一块“从属”网卡，服务于“主”网卡，不应该再有自己的IP地址等信息。</strong>在进行了初始设置之后，它们就可以支持网卡绑定。</p>
<ul>
<li><p>命令:vim /etc/sysconfig/network-scripts/ifcfg-网卡名称1</p>
<ul>
<li><p>修改后的代码</p>
<p>  TYPE=Ethernet<br>  BOOTPROTO=none<br>  ONBOOT=yes<br>  USERCTL=no<br>  DEVICE=eno16777736<br>  MASTER=bond0<br>  SLAVE=yes<br>  [root@linux</p>
</li>
</ul>
</li>
<li><p>命令:vim /etc/sysconfig/network-scripts/ifcfg-网卡名称2</p>
<ul>
<li><p>修改后的代码</p>
<p>  TYPE=Ethernet<br>  BOOTPROTO=none<br>  ONBOOT=yes<br>  USERCTL=no<br>  DEVICE=eno33554968<br>  MASTER=bond0<br>  SLAVE=yes</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>3.将绑定后的设备命名为bond0,并把IP等信息填写进去</p>
<ul>
<li><p>命令:vim /etc/sysconfig/network-scripts/ifcfg-bond0</p>
<ul>
<li><p>代码</p>
<p>  TYPE=Ethernet<br>  BOOTPROTO=none<br>  ONBOOT=yes<br>  USERCTL=no<br>  DEVICE=bond0<br>  IPADDR=192.168.10.10<br>  PREFIX=24<br>  DNS=192.168.10.1<br>  NM_CONTROLLED=no</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>4.让Linux内核支持网卡绑定驱动</p>
<p>  比如有一台用于提供NFS或者samba服务的文件服务器，它所能提供的最大网络传输速度为100Mbit/s，但是访问该服务器的用户数量特别多，那么它的访问压力一定很大。在生产环境中，网络的可靠性是极为重要的，而且网络的传输速度也必须得以保证。针对这样的情况，比较好的选择就是mode6网卡绑定驱动模式了。因为mode6能够让两块网卡同时一起工作，当其中一块网卡出现故障后能自动备援，且无需交换机设备支援，从而提供了可靠的网络传输保障。</p>
<ul>
<li><p>使用Vim创建一个用于网卡绑定的驱动文件,是的绑定后的bond0网卡设备支持绑定技术(bonding),同时定义网卡以mode6模式进行绑定,且出现故障时自动切换的时间为100毫秒</p>
<ul>
<li><p>命令:vim /etc/modprobe.d/bond.conf</p>
<ul>
<li><p>代码</p>
<p>  alias bond0 bonding<br>  options bond0 miimon=100 mode=6</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>常见的三种模式</p>
<ul>
<li><p>mode0 : 平衡负载模式）：平时两块网卡均工作，且自动备援，但需要在与服务器本地网卡相连的交换机设备上进行端口聚合来支持绑定技术。</p>
</li>
<li><p>mode1 : 平时只有一块网卡工作，在它故障后自动替换为另外的网卡。</p>
</li>
<li><p>mode6 : 平时两块网卡均工作，且自动备援，无须交换机设备提供辅助支持。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>5.重启服务命令:systemctl restart network<br>(<strong>正常情况下只有bond0网卡设备才会有IP地址等信息</strong>)</p>
</li>
</ul>
</li>
<li><p>参考:Linux网卡配置文件详解</p>
<p>  <a href="https://www.cnblogs.com/zuikeol/p/9647671.html" target="_blank" rel="noopener">https://www.cnblogs.com/zuikeol/p/9647671.html</a></p>
</li>
</ul>
</li>
</ul>
<pre><code>    Linux网卡配置文件详解：
    DEVICE=eth0 #指出设备名称 NM_CONTROLLED=yes #network mamager的参数，实时生效，不需要重启 ONBOOT=yes #设置为yes，开机自动启用网络连接 IPADDR=192.168.21.129 #IP地址 BOOTPROTO=none #设置为none禁止DHCP，设置为static启用静态IP地址，设置为dhcp开启DHCP服务 NETMASK=255.255.255.0 #子网掩码 DNS1=8.8.8.8 #第一个dns服务器 TYPE=Ethernet #网络类型为：Ethernet GATEWAY=192.168.21.2 #设置网关 DNS2=8.8.4.4 #第二个dns服务器 IPV6INIT=no #禁止IPV6 USERCTL=no #是否允许非root用户控制该设备，设置为no，只能用root用户更改 HWADDR=00:0C:29:2C:E1:0F #网卡的Mac地址 PREFIX=24 DEFROUTE=yes IPV4_FAILURE_FATAL=yes NAME=&quot;System eth0&quot; #定义设备名称</code></pre><ul>
<li><p>9.2 远程控制服务</p>
<ul>
<li><p>9.2.1 配置sshd服务</p>
<p>  SSH（Secure <a href="https://www.linuxcool.com/" target="_blank" rel="noopener">Shell</a>）是一种能够以安全的方式提供远程登录的协议，也是目前远程管理Linux系统的首选方式。在此之前，一般使用FTP或Telnet来进行远程登录。但是因为它们以明文的形式在网络中传输账户密码和数据信息，因此很不安全，很容易受到黑客发起的中间人攻击，这轻则篡改传输的数据信息，重则直接抓取服务器的账户密码。</p>
<p>  想要使用SSH协议来远程管理Linux系统，则需要部署配置sshd服务程序。sshd是基于SSH协议开发的一款远程管理服务程序，不仅使用起来方便快捷，而且能够提供两种安全验证的方法：</p>
<p>  基于口令的验证—用账户和密码来验证登录；</p>
<p>  基于密钥的验证—需要在本地生成密钥对，然后把密钥对中的公钥上传至服务器，并与服务器中的公钥进行比较；该方式相较来说更安全。</p>
<p>  前文曾多次强调“Linux系统中的一切都是文件”，因此在Linux系统中修改服务程序的运行参数，实际上就是在修改程序配置文件的过程。sshd服务的配置信息保存在/etc/ssh/sshd_config文件中。运维人员一般会把保存着最主要配置信息的文件称为主配置文件，而配置文件中有许多以井号开头的注释行，要想让这些配置参数生效，需要在修改参数后再去掉前面的井号。</p>
<ul>
<li><p>sshd服务配置文件中的重要参数</p>
<ul>
<li><p>Port 22    默认的sshd服务端口</p>
</li>
<li><p>ListenAddress 0.0.0.0    设定sshd服务器监听的IP地址</p>
</li>
<li><p>Protocol 2    SSH协议的版本号</p>
</li>
<li><p>HostKey /tc/ssh/ssh_host_key    SSH协议版本为1时，DES私钥存放的位置</p>
</li>
<li><p>HostKey /etc/ssh/ssh_host_rsa_key    SSH协议版本为2时，RSA私钥存放的位置</p>
</li>
<li><p>HostKey /etc/ssh/ssh_host_dsa_key    SSH协议版本为2时，DSA私钥存放的位置</p>
</li>
<li><p>PermitRootLogin yes    设定是否允许root管理员直接登录</p>
</li>
<li><p>StrictModes yes    当远程用户的私钥改变时直接拒绝连接</p>
</li>
<li><p>MaxAuthTries 6    最大密码尝试次数</p>
</li>
<li><p>MaxSessions 10    最大终端数</p>
</li>
<li><p>PasswordAuthentication yes    是否允许密码验证</p>
</li>
<li><p>PermitEmptyPasswords no    是否允许空密码登录（很不安全）</p>
</li>
</ul>
</li>
<li><p>配置的例子</p>
<ul>
<li><p>例子</p>
<ul>
<li><p>如果禁止以root管理员的身份远程登录到服务器</p>
<p>  首先使用Vim文本编辑器打开sshd服务的主配置文件，然后把第48行#PermitRootLogin yes参数前的井号（#）去掉，并把参数值yes改成no，这样就不再允许root管理员远程登录了</p>
<p>  [root@linuxprobe ~]# vim /etc/ssh/sshd_config<br>   ………………省略部分输出信息………………<br>   46<br>   47 #LoginGraceTime 2m<br>   48 PermitRootLogin no<br>   49 #StrictModes yes<br>   50 #MaxAuthTries 6<br>   51 #MaxSessions 10<br>   52<br>   ………………省略部分输出信息………………</p>
</li>
<li><p>重启服务并使用systemctl enable sshd 让sshd服务开启自动运行</p>
<p>  再次提醒的是，一般的服务程序并不会在配置文件修改之后立即获得最新的参数。如果想让新配置文件生效，则需要手动重启相应的服务程序。最好也将这个服务程序加入到开机启动项中，这样系统在下一次启动时，该服务程序便会自动运行，继续为用户提供服务。<br>  [root@linuxprobe ~]# systemctl restart sshd<br>  [root@linuxprobe ~]# systemctl enable sshd</p>
</li>
</ul>
</li>
<li><p>问题与解决</p>
<ul>
<li><p>SSH连接显示:ssh_exchange_identification:read connection reset by beer解决办法</p>
<p>  修改SSH配置文件:<br>  /etc/ssh/sshd_config<br>  将MaxSessions 设置为更多</p>
<p>  或者  </p>
<p>  修改<br>  /etc/hosts.allow  </p>
<p>  追加sshd:ALL</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>两种验证方法:基于口令验证和秘钥验证</p>
</li>
</ul>
</li>
<li><p>9.2.2 安全秘钥验证</p>
<ul>
<li><p>步骤</p>
<ul>
<li><p>1.在客户端主机中生成”秘钥对”</p>
<ul>
<li><p>命令:ssh-keygen</p>
<ul>
<li><p>示例</p>
<p>  [root@linuxprobe ~]# ssh-keygen  </p>
<p>  Generating public/private rsa key pair.<br>  Enter file in which to save the key (/root/.ssh/id_rsa):<strong>按回车键或设置密钥的存储路径</strong><br>  Created directory ‘/root/.ssh’.<br>  Enter passphrase (empty for no passphrase):<strong>直接按回车键或设置密钥的密码</strong><br>  Enter same passphrase again:<strong>再次按回车键或设置密钥的密码</strong></p>
<p>  Your identification has been saved in /root/.ssh/id_rsa.<br>  Your public key has been saved in /root/.ssh/id_rsa.pub.<br>  Your identification has been saved in /root/.ssh/id_rsa.<br>  Your public key has been saved in /root/.ssh/id_rsa.pub.<br>  The key fingerprint is:<br>  40:32:48:18:e4:ac:c0:c3:c1:ba:7c:6c:3a:a8:b5:22 <a href="mailto:root@linuxprobe.com">root@linuxprobe.com</a><br>  The key’s randomart image is:<br>  +–[ RSA 2048]—-+<br>  |+<em>..o .          |<br>  |</em>.o  +           |<br>  |o*    .          |<br>  |+ .    .         |<br>  |o..     S        |<br>  |.. +             |<br>  |. =              |<br>  |E+ .             |<br>  |+.o              |<br>  +—————–+</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.把客户端中生成的公钥文件传输至远程主机</p>
<ul>
<li><p>命令:ssh-copy-id 远程主机IP地址</p>
<ul>
<li><p>示例</p>
<p>  [root@linuxprobe ~]# ssh-copy-id 192.168.10.10<br>  The authenticity of host ‘192.168.10.20 (192.168.10.10)’ can’t be established.<br>  ECDSA key fingerprint is 4f:a7:91:9e:8d:6f:b9:48:02:32:61:95:48:ed:1e:3f.<br>  Are you sure you want to continue connecting (yes/no)? yes<br>  /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed<br>  /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed – if you are prompted now it is to install the new keys<br>  <a href="mailto:root@192.168.10.10">root@192.168.10.10</a>‘s password:<strong>此处输入远程服务器密码</strong><br>  Number of key(s) added: 1<br>  Now try logging into the machine, with: “ssh ‘192.168.10.10’”<br>  and check to make sure that only the key(s) you wanted were added.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>3.对服务器进行设置,使其只允许秘钥验证,拒绝传统的口令验证方式(记得在修改后保存并重启sshd服务</p>
<ul>
<li><p>命令:vim /etc/ssh/sshd_config</p>
<ul>
<li><p>示例</p>
<p>  [root@linuxprobe ~]# vim /etc/ssh/sshd_config<br>   ………………省略部分输出信息………………<br>   74<br>   75 # To disable tunneled clear text passwords, change to no here!<br>   76 #PasswordAuthentication yes<br>   77 #PermitEmptyPasswords no<br>   78 PasswordAuthentication no<br>   79<br>   ………………省略部分输出信息………………<br>  [root@linuxprobe ~]# systemctl restart sshd</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>9.2.3 远程传输命令 scp</p>
<p>  scp（secure copy）是一个基于SSH协议在网络之间进行安全传输的命令，其格式为“scp [参数] 本地文件 远程帐户@远程IP地址:远程目录”。<br>  与第2章讲解的cp命令不同，cp命令只能在本地硬盘中进行文件复制，而scp不仅能够通过网络传送数据，而且所有的数据都将进行加密处理。例如，如果想把一些文件通过网络从一台主机传递到其他主机，这两台主机又恰巧是Linux系统，这时使用scp命令就可以轻松完成文件的传递了。scp命令中可用的参数以及作用如表9-2所示。</p>
<ul>
<li><p><strong>上传</strong>命令格式: scp [参数] 本地文件 远程账户@远程IP地址:远程目录</p>
<ul>
<li><p>命令参数</p>
<ul>
<li><p>-v    显示详细的连接进度</p>
</li>
<li><p>-P    指定远程主机的sshd端口号</p>
</li>
<li><p>-r    用于传送文件夹</p>
</li>
<li><p>-6    使用IPv6协议</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用说明</p>
<ul>
<li><p>首先需要以绝对路径的形式写清本地文件的存放位置</p>
</li>
<li><p>如果要传送整个文件夹内的所有数据,还要额外添加参数-r进行递归操作,然后写上远程主机的IP地址</p>
</li>
<li><p>当用户名为<strong>root</strong>,而<strong>密码则为远程服务器的密码</strong>,如果想使用指定用户的身份进行验证,可以使用 <strong>用户名@主机地址</strong> 的参数格式</p>
</li>
<li><p>最后要在远程主机地址后面添加 : 号,并在后面写上要传输到远程主机的那个文件夹中</p>
</li>
<li><p>使用例子</p>
<p>  [root@linuxprobe ~]# echo “Welcome to LinuxProbe.Com” &gt; readme.txt<br>  [root@linuxprobe ~]# scp /root/readme.txt 192.168.10.20:/home<br>  <a href="mailto:root@192.168.10.20">root@192.168.10.20</a>‘s password:此处输入远程服务器中root管理员的密码<br>  readme.txt 100% 26 0.0KB/s 00:00</p>
</li>
</ul>
</li>
<li><p>从远程主机<strong>下载</strong>命令格式: scp [参数] 远程用户@远程iP地址:远程文件 本地目录</p>
<ul>
<li><p>使用例子</p>
<p>  [root@linuxprobe ~]# scp 192.168.10.20:/etc/redhat-release /root<br>  <a href="mailto:root@192.168.10.20">root@192.168.10.20</a>‘s password:此处输入远程服务器中root管理员的密码<br>  redhat-release 100% 52 0.1KB/s 00:00<br>  [root@linuxprobe ~]# cat redhat-release<br>  Red Hat Enterprise Linux Server release 7.0 (Maipo)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>9.3 不间断会话服务</p>
<p>  大家在学习sshd服务时，不知有没有注意到这样一个事情：当与远程主机的会话被关闭时，在远程主机上运行的命令也随之被中断。</p>
</li>
</ul>
<pre><code>如果我们正在使用命令来打包文件，或者正在使用脚本安装某个服务程序，中途是绝对不能关闭在本地打开的终端窗口或断开网络链接的，甚至是网速的波动都有可能导致任务中断，此时只能重新进行远程链接并重新开始任务。还有些时候，我们正在执行文件打包操作，同时又想用脚本来安装某个服务程序，这时会因为打包操作的输出信息占满用户的屏幕界面，而只能再打开一个执行远程会话的终端窗口，时间久了，难免会忘记这些打开的终端窗口是做什么用的了。  


screen是一款能够实现多窗口远程控制的开源服务程序，简单来说就是为了解决网络异常中断或为了同时控制多个远程终端窗口而设计的程序。用户还可以使用screen服务程序同时在多个远程会话中自由切换，能够做到实现如下功能。

- 使用Yum仓库 安装 Screen

    - 步骤

        1.  
        首先将虚拟机的CD/DVD光盘选项设置为“使用ISO镜像文件”，并选择已经下载好的系统镜像，

        2.  
        把光盘设备中的系统镜像挂载到/media/cdrom目录

        [root@linuxprobe ~]# mkdir -p /media/cdrom  
        [root@linuxprobe ~]# mount /dev/cdrom /media/cdrom  

        3.  
        使用Vim文本编辑器创建Yum仓库的配置文件

        [root@linuxprobe ~]# vim /etc/yum.repos.d/rhel7.repo  
        [rhel7]  
        name=rhel7  
        baseurl=file:///media/cdrom  
        enabled=1  
        gpgcheck=0  


        4.  
        使用yum install screen 命令
        安装screen

- 9.3.1 管理远程会话服务

    - 例子

        创建一个名为 backup 的会话窗口

        screen -S backup  

        查看ls,进行中的会话

        screen -ls  

        退出  
        exit  

        在日常的生产环境中，其实并不是必须先创建会话，然后再开始工作。可以直接使用screen命令执行要运行的命令，这样在命令中的一切操作也都会被记录下来，当命令执行结束后screen会话也会自动结束

        screen vim memo.txt  


        恢复会话  
        screen -r linux

    - 常用命令参数

        -S 创建会话窗口

        -d 指定会话进行离线处理

        -r 恢复指定会话

        -x 一次性恢复所有的会话

        -ls 显示当前已有的会话

        -wipe 把目前无法使用的会话删除

- 9.3.2 会话共享服务

    screen命令不仅可以确保用户在极端情况下也不丢失对系统的远程控制，保证了生产环境中远程工作的不间断性，而且它还具有会话共享、分屏切割、会话锁定等实用的功能。其中，会话共享功能是一件很酷的事情，当多个用户同时控制主机的时候，它可以把屏幕内容共享出来，也就是说每个用户都可以看到相同的内容。

    - 如何使用?

        要实现会话共享功能，首先使用ssh服务程序将终端A远程连接到服务器，并创建一个会话窗口。

        ssh 192.168.10.10  

        screen -S linuxprobe  


        然后，使用ssh服务程序将终端B远程连接到服务器，并执行获取远程会话的命令。接下来，两台主机就能看到相同的内容了。

        ssh 192.168.10.10  

        screen -x 

    - 

- 可实现的功能

    **会话恢复**：即便网络中断，也可让会话随时恢复，确保用户不会失去对远程会话的控制。

    **多窗口**：每个会话都是独立运行的，拥有各自独立的输入输出终端窗口，终端窗口内显示过的信息也将被分开隔离保存，以便下次使用时依然能看到之前的操作记录。

    **会话共享**：当多个用户同时登录到远程服务器时，便可以使用会话共享功能让用户之间的输入输出信息共享。</code></pre><ul>
<li><p>章节概述</p>
<p>  本章讲解了如何使用nmtui<a href="https://www.linuxcool.com/" target="_blank" rel="noopener">命令</a>配置网络参数，以及通过nmcli<a href="https://www.linuxcool.com/" target="_blank" rel="noopener">命令</a>查看网络信息并管理网络会话服务，从而让您能够在不同工作场景中快速地切换网络运行参数；还讲解了如何手工绑定mode6模式双网卡，实现网络的负载均衡。。<br>  本章还深入介绍了SSH协议与sshd服务程序的理论知识、<a href="https://www.linuxprobe.com/" target="_blank" rel="noopener">Linux系统</a>的远程管理方法以及在系统中配置服务程序的方法，并采用实验的形式演示了使用基于密码验证的sshd服务程序进行远程登录，以及使用screen服务程序远程管理Linux系统的不间断会话等技术。<br>  当读者掌握了本章的内容之后，也就完全具备了对Linux系统进行配置管理的知识。而且后续章节中将陆续引入大量实用服务的配置内容，读者将用到本章学习的知识进行配置，这样一方面可以让读者对生产环境中用到的大多数热门服务程序有一个广泛且深入的认识，另一方面也可以掌握相应的配置方法。</p>
</li>
</ul>
<h3 id="第十章-使用Apache服务部署静态网站"><a href="#第十章-使用Apache服务部署静态网站" class="headerlink" title="第十章 使用Apache服务部署静态网站"></a>第十章 使用Apache服务部署静态网站</h3><p>本章目录结构:</p>
<pre><code>[10.1 网站服务程序](https://www.linuxprobe.com/chapter-10.html#101)
[10.2 配置服务文件参数](https://www.linuxprobe.com/chapter-10.html#102)
[10.3 SELinux安全子系统](https://www.linuxprobe.com/chapter-10.html#103SELinux)
[10.4 个人用户主页功能](https://www.linuxprobe.com/chapter-10.html#104)
[10.5 虚拟网站主机功能](https://www.linuxprobe.com/chapter-10.html#105)
[10.5.1 基于IP地址](https://www.linuxprobe.com/chapter-10.html#1051_IP)
[10.5.2 基于主机域名](https://www.linuxprobe.com/chapter-10.html#1052)
[10.5.3 基于端口号](https://www.linuxprobe.com/chapter-10.html#1053)
[10.6 Apache的访问控制](https://www.linuxprobe.com/chapter-10.html#106_Apache)</code></pre><ul>
<li><p>网站服务程序</p>
<ul>
<li><p>10.1 部署Apache</p>
<ul>
<li><p>安装</p>
<ol>
<li><p>将光盘镜像挂载到media/cdrom 目录  </p>
</li>
<li><p>并vim /etc/yum.repos.d/rhel7.repo配置yum(参考4.1.4小节)  </p>
</li>
<li><p>yum install httpd 安装apache服务<br>(有的的系统已经默认安装了)  </p>
</li>
<li><p>启动服务并设置开机启动<br>systemctl start httpd<br>systemctl enable httpd  </p>
<p>5<br>浏览器打开127.0.0.1应该就可以看到服务了</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>10.2 配置服务文件参数</p>
<ul>
<li><p>httpd 配置文件</p>
<p>  服务目录 : /etc/httpd<br>  主配置文件: /etc/httpd/conf/httpd.conf<br>  网站数据目录: /var/www/html<br>  访问日志:/var/log/httpd/access_log<br>  错误日志:/var/log/httpd/error_log</p>
<ul>
<li><p>/etc/httpd/conf/httpd.conf配置文件内容解释</p>
<h1 id="为注释行对配置和参数的介绍"><a href="#为注释行对配置和参数的介绍" class="headerlink" title="为注释行对配置和参数的介绍"></a>为注释行对配置和参数的介绍</h1></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>            全局配置  
            ServerRoot “/etc/httpd”  
            ServerName [www.linuxprobe.com](http://www.linuxprobe.com)



            &lt;Directory /&gt;  
            区域配置  
            &lt;/Directory&gt;  

            &lt;Location /server-status&gt;  
            区域配置  
            &lt;/Location&gt;

            - 全局配置与区域配置

                全局配置:可以作用于所有的子站点  

                既保障了子站点正常访问,也有效减少了频繁写入重复参数的工作量  

                区域配置:  

                区域配置参数则是单独针对于每个独立的子站点进行设置的  

                举例:  
                就像在大学食堂里面打饭，食堂负责打饭的阿姨先给每位同学来一碗标准大小的白饭（全局配置），然后再根据每位同学的具体要求盛放他们想吃的菜（区域配置）

                - **常用的目录参数以及用途描述**

                    ServerRoot  
                    服务目录  
                    ServerAdmin  
                    管理员邮箱  
                    User  
                    运行服务的用户  

                    Group  
                    运行服务的用户组  

                    ServerName  
                    网站服务器的域名  

                    DocumentRoot  
                    网站数据目录  

                    Listen  
                    监听的IP地址与端口号

                    DirectoryIndex  
                    默认的索引页页面  

                    ErrorLog  
                    错误日志文件  

                    CustomLog  
                    访问日志文件  

                    Timeout  
                    网页超时时间，默认为300秒

                    - **documentRoot参数**用于定义**网站数据的保存路径**，其参数的默认值是把网站数据存放**到/var/www/html目录**中；而当前网站普遍的**首页**面名称是**index.html**，因此可以向/var/www/html目录中写入一个文件，替换掉httpd服务程序的默认首页面，该操作会立即生效。

        - 实践操作

            - 1.尝试第一个首页

                DocumentRoot参数用于定义网站数据保存路径,默认是/var/www/html目录  

                1.  
                给/var/www/html目录写入一个index.html文件看看有什么变化  

                命令:  
                echo “welcome to [linuxprobe.com](http://linuxprobe.com)” &gt; /var/www/html/index.html

                打开浏览器会发现变成了上面的这行字

            - 2.尝试修改默认目录 :   
              119行DocumentRoot 和 124行 Directory的路径

                1.  
                新建一个目录  
                $ mkdir /home/wwwroot  

                $ echo “The New Web Directory” &gt; /home/wwwroot/index.html  

                2.  
                打开httpd主配置文件(/etc/httpd/conf/httpd.conf,修改119行:DocumentRoot和124行的Directory的默认路径为/home/wwwroot  

                3.  
                重启httpd服务并查看效果会发现竟然是httpd服务程序的默认首页  

                **这一切是SELinux在捣鬼**

                - **错误源于SELinux安全子系统**

- **10.3 SELinux 安全子系统**

    SELinux（Security-Enhanced Linux）是美国国家安全局在Linux开源社区的帮助下开发的一个强制访问控制（MAC，Mandatory Access Control）的安全子系统。RHEL 7系统使用SELinux技术的目的是为了让各个服务进程都受到约束，使其仅获取到本应获取的资源。
    例如，您在自己的电脑上下载了一个美图软件，当您全神贯注地使用它给照片进行美颜的时候，它却在后台默默监听着浏览器中输入的密码信息，而这显然不应该是它应做的事情（哪怕是访问电脑中的图片资源，都情有可原）。SELinux安全子系统就是为了杜绝此类情况而设计的，它能够从多方面监控违法行为：对服务程序的功能进行限制（SELinux域限制可以确保服务程序做不了出格的事情）；对文件资源的访问限制（SELinux安全上下文确保文件资源只能被其所属的服务程序进行访问）。

    - **三种配置模式**

        - **enforcing : 强制启用安全策略模式,将拦截不合法的请求** 

        - **permissive : 遇到服务越权访问时,只发出警告而不强制拦截**

        - **disabled : 对越权行为不警告也不拦截**

    - **检查SELinux是否开了强制启动安全策略**

        命令:

        vim /etc/selinux/config

    - **实践操作**

        - **1.判断问题并查看上下文**

            1.获取当前SELinux服务的运行模式

            $ getenforce  

            2.  
            修改SELinux当前运行模式(临时修改)  

            $ setenforce 0(关) 1 (开)  

            3.  
            再次刷新网页就可以看到内容了,确定是SELinux在捣乱  

            4.  
            恢复强制启动安全策略模式,然后分别查看原始网站数据的保存目录与当前网站数据的不保存目录是否拥有不同的SELinux安全上下值  

            $ setenforce 1  

            ls -Zd /var/www/html  

            ls -Zd /home/wwwroot  

            *ls -Z 是查看SELinux文件上下文的意思,只有在SELinux启动中才有效  

            *  
            用户段system_u代表系统进程的身份
            角色段object_r代表文件目录的角色
            类型段httpd_sys_content_t代表网站服务的系统文件

        - **2.使用semanage命令将当前目录修改为和原始网站目录一样**

            1.  
            像新网站数据目录中添加一条SELinux安全上下文,让这个目录以及里面的所有文件都你能被httpd服务程序访问到

            $ semanage fcontext -a -t httpd_sys_content_t /home/wwwroot  

            $ semanage fcontext -a -f httpd_sys_content_t /home/wwwroot/*

            - **semanage命令**

                semanage命令不仅能够像传统chcon命令那样—设置文件、目录的策略，还可以管理网络端口、消息接口（这些新特性将在本章后文中涵盖）。

                - **格式:semanage [选项] [文件]**

                - **常用参数和功能:**

                    - **-l参数用于查询；**

                    - **-a参数用于添加；**

                    - **-m参数用于修改；**

                    - **-d参数用于删除。**

                    - **fcontext : 用于安全上下文**

        - **3.使用restorecon命令让SELinux安全上下文立即生效**

            $ restorecon -Rv /home/wwwroot/

        - **总结SELinux目前用到的四个命令**

            - **1.getenforce 2.setenforce 3.semanage - semanage fcontext 4.restoreconf -Rv /xxx 5.ls -Zd /xxx  简称:gssr**

    - **问题所在**

        httpd服务程序的功能是允许用户访问网站内容，因此SELinux肯定会默认放行用户对网站的请求操作。但是，我们将网站数据的默认保存目录修改为了/home/wwwroot，而这就产生问题了。在6.1小节中讲到，/home目录是用来存放普通用户的家目录数据的，而现在，httpd提供的网站服务却要去获取普通用户家目录中的数据了，这显然违反了SELinux的监管原则。

- 10.4 个人用户主页功能

    如果想在系统中为每位用户建立一个独立的网站，通常的方法是基于虚拟网站主机功能来部署多个网站。但这个工作会让管理员苦不堪言（尤其是用户数量很庞大时），而且在用户自行管理网站时，还会碰到各种权限限制，需要为此做很多额外的工作。其实，httpd服务程序提供的个人用户主页功能完全可以胜任这个工作。该功能可以让系统内所有的用户在自己的家目录中管理个人的网站，而且访问起来也非常容易

    - **步骤**

        **1.**  
        编辑配置文件(/etc/httpd/conf.d/userdir.conf),开启httpd的’个人主页’功能

        在配置文件中  

        1-1  
        UserDir disabled 参数前面**添加#号**,表示让httpd服务程序开启个人主页功能


        1-2  
        把第二四行的UserDir public_html **#号去掉**

        ***UserDir参数表示网站数据在用户家目录中保存的目录名称**  


        **2.**  
        在用户家目录添加目录以及首页文件,并把权限修改为755  

        [root@linuxprobe home]# su - linuxprobe  
        Last login: Fri May 22 13:17:37 CST 2017 on :0  
        [linuxprobe@linuxprobe ~]$ mkdir public_html  
        [linuxprobe@linuxprobe ~]$ echo &quot;This is linuxprobe&apos;s website&quot; &gt; public_html/index.html  
        [linuxprobe@linuxprobe ~]$ chmod -Rf 755 /home/linuxprobe  

        发现不行,还是SELinux的问题

        解决:

        使用命令: getsebool -a | grep http 看看那个和这个服务相关 on 为开 off为关

        使用命令:  
        setsebool -P httpd_enalbe_homedirs=on让这个策略生效即可

    - **添加口令功能**

        - **步骤**

            1.  
            使用命令  htpasswd 命令生成密码数据库

            -c 参数表示第一次生成

            格式 : 

            htpasswd -c /etc/httpd/passwd     要用到的用户名(不必一定是系统中的本地账号)

            修改配置文件(/etc/httpd/conf.d/userdir.conf)的第31-35行为:  

            31 &lt;Directory &quot;/home/*/public_html&quot;&gt;  
            32 AllowOverride all  
            #刚刚生成出来的密码验证文件保存路径
            33 authuserfile &quot;/etc/httpd/passwd&quot;  
            #当用户尝试访问个人用户网站时的提示信息
            34 authname &quot;My privately website&quot;  
            35 authtype basic  
            #用户进行账户密码登录时需要验证的用户名称
            36 require user linuxprobe  
            37 &lt;/Directory&gt;

- **10.5 虚拟主机网站功能**

    - **10.5.1 基于IP地址**

        如果一台服务器有多个IP地址，而且每个IP地址与服务器上部署的每个网站一一对应，这样当用户请求访问不同的IP地址时，会访问到不同网站的页面资源。而且，每个网站都有一个独立的IP地址，对搜索引擎优化也大有裨益。因此以这种方式提供虚拟网站主机功能不仅最常见，也受到了网站站长的欢迎（尤其是草根站长）。

        - **步骤**

            1.  
            配置三个IP用于做实验:使用nmtui命令  

            2.  
            分别在/home/wwwroot 中创建 用于保存不同网站数据的三个目录,并向其中分别写入网站的首页文件  

            3.  
            打开httpd配置文件,从113行开始追加三个基于IP地址的虚拟主机参数  

            [root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf  
            ………………省略部分输出信息………………
            113 &lt;VirtualHost 192.168.10.10&gt;  
            114 DocumentRoot /home/wwwroot/10  
            115 ServerName www.linuxprobe.com  
            116 &lt;Directory /home/wwwroot/10 &gt;  
            117 AllowOverride None  
            118 Require all granted  
            119 &lt;/Directory&gt;  
            120 &lt;/VirtualHost&gt;  
            121 &lt;VirtualHost 192.168.10.20&gt;  
            122 DocumentRoot /home/wwwroot/20  
            123 ServerName [bbs.linuxprobe.com](http://bbs.linuxprobe.com)

            124 &lt;Directory /home/wwwroot/20 &gt;  
            125 AllowOverride None  
            126 Require all granted  
            127 &lt;/Directory&gt;  
            128 &lt;/VirtualHost&gt;  

            129 &lt;VirtualHost 192.168.10.30&gt;  
            130 DocumentRoot /home/wwwroot/30  
            131 ServerName tech.linuxprobe.com  
            132 &lt;Directory /home/wwwroot/30 &gt;  
            133 AllowOverride None  
            134 Require all granted  
            135 &lt;/Directory&gt;  
            136 &lt;/VirtualHost&gt;  
            ………………省略部分输出信息………………
            [root@linuxprobe ~]# systemctl restart httpd  


            4.  
            如果访问网站看到httpd的默认首页,也是SELinux在捣鬼,我们需要手动把新的网站数据目录的SELinux安全上下文设置正确（见前文的实验），并使用restorecon命令让新设置的SELinux安全上下文立即生效(这里我没有设置也可以了,不知道为什么,但重启httpd服务后就不行)

            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot  
            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/10  
            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/10/*  
            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/20  
            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/20/*  
            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/30  
            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/30/*  
            [root@linuxprobe ~]# restorecon -Rv /home/wwwroot

    - **10.5.2 基于域名**

        当服务器无法为每个网站都分配一个独立IP地址的时候，可以尝试让Apache自动识别用户请求的域名，从而根据不同的域名请求来传输不同的内容。在这种情况下的配置更加简单，只需要保证位于生产环境中的服务器上有一个可用的IP地址（这里以192.168.10.10为例）就可以了。由于当前还没有介绍如何配置DNS解析服务，因此需要手工定义IP地址与域名之间的对应关系。/etc/hosts是Linux系统中用于强制把某个主机域名解析到指定IP地址的配置文件。简单来说，只要这个文件配置正确，即使网卡参数中没有DNS信息也依然能够将域名解析为某个IP地址。

        - **步骤**

            1.  
            手动定义IP地址与域名之间对应关系的配置文件,保存并退出后立即生效

            [root@linuxprobe ~]# vim /etc/hosts  
            127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4  
            ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6  
            192.168.10.10 www.linuxprobe.com bbs.linuxprobe.com [tech.linuxprobe.com](http://tech.linuxprobe.com)


            2.  

            分别在/home/wwwroot目录中创建用于保存不同网站数据的三个目录,并向其中分别写入网站的首页文件(之前基于IP配置增加的目录是10/20/30,这次是/www/bbs/tech

            [root@linuxprobe ~]# mkdir -p /home/wwwroot/www  
            [root@linuxprobe ~]# mkdir -p /home/wwwroot/bbs  
            [root@linuxprobe ~]# mkdir -p /home/wwwroot/tech  
            [root@linuxprobe ~]# echo &quot;WWW.linuxprobe.com&quot; &gt; /home/wwwroot/www/index.html  
            [root@linuxprobe ~]# echo &quot;BBS.linuxprobe.com&quot; &gt; /home/wwwroot/bbs/index.html  
            [root@linuxprobe ~]# echo &quot;TECH.linuxprobe.com&quot; &gt; /home/wwwroot/tech/index.html  


            3.  
            配置httpd文件,从113行开始分别写入三个基于主机名的虚拟主机网站参数,然后保存退户

            [root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf  
            ………………省略部分输出信息………………
            113 &lt;VirtualHost 192.168.10.10&gt;  
            114 DocumentRoot &quot;/home/wwwroot/www&quot;  
            115 ServerName &quot;www.linuxprobe.com&quot;  
            116 &lt;Directory &quot;/home/wwwroot/www&quot;&gt;  
            117 AllowOverride None  
            118 Require all granted  
            119 &lt;/directory&gt;   
            120 &lt;/VirtualHost&gt;  
            121 &lt;VirtualHost 192.168.10.10&gt;  
            122 DocumentRoot &quot;/home/wwwroot/bbs&quot;  
            123 ServerName &quot;bbs.linuxprobe.com&quot;  
            124 &lt;Directory &quot;/home/wwwroot/bbs&quot;&gt;  
            125 AllowOverride None  
            126 Require all granted  
            127 &lt;/Directory&gt;  
            128 &lt;/VirtualHost&gt;  
            129 &lt;VirtualHost 192.168.10.10&gt;  
            130 DocumentRoot &quot;/home/wwwroot/tech&quot;  
            131 ServerName &quot;tech.linuxprobe.com&quot;  
            132 &lt;Directory &quot;/home/wwwroot/tech&quot;&gt;  
            133 AllowOverride None  
            134 Require all granted  
            135 &lt;/directory&gt;  
            136 &lt;/VirtualHost&gt;  
            ………………省略部分输出信息………………


            4.  
            设置SELinux上下文(这里我没有设置也可以了,不知道为什么)

            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot  
            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/www  
            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/www/*  
            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/bbs  
            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/bbs/*  
            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/tech  
            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/tech/*  
            [root@linuxprobe ~]# restorecon -Rv /home/wwwroot

    - **10.5.3 基于端口号**

        基于端口号的虚拟主机功能可以让用户通过指定的端口号来访问服务器上的网站资源。在使用Apache配置虚拟网站主机功能时，基于端口号的配置方式是最复杂的。因此我们不仅要考虑httpd服务程序的配置因素，还需要考虑到SELinux服务对新开设端口的监控。一般来说，使用80、443、8080等端口号来提供网站访问服务是比较合理的，如果使用其他端口号则会受到SELinux服务的限制。
        在接下来的实验中，我们不但要考虑到目录上应用的SELinux安全上下文的限制，还需要考虑SELinux域对httpd服务程序的管控。

        - **步骤**

            1.  
            分别在/home/wwwroot中创建用于保存不同网站数据的两个目录,并向其中写入存放首页的文件

            [root@linuxprobe ~]# mkdir -p /home/wwwroot/6111  
            [root@linuxprobe ~]# mkdir -p /home/wwwroot/6222  
            [root@linuxprobe ~]# echo &quot;port:6111&quot; &gt; /home/wwwroot/6111/index.html  
            [root@linuxprobe ~]# echo &quot;port:6222&quot; &gt; /home/wwwroot/6222/index.html  

            2.  
            **在httpd服务配置文件的第43行和第44行分别添加用于监听6111和6222端口的参数**

            42 Listen 80  
             43 Listen 6111  
             44 Listen 6222  


            3.  
            在httpd服务的配置文件中大约113行处开始，分别追加写入两个基于端口号的虚拟主机网站参数，然后保存并退出。记得需要重启httpd服务，这些配置才生效

            113 &lt;VirtualHost 192.168.10.10:6111&gt;  
            114 DocumentRoot &quot;/home/wwwroot/6111&quot;  
            115 ServerName www.linuxprobe.com  
            116 &lt;Directory &quot;/home/wwwroot/6111&quot;&gt;  
            117 AllowOverride None  
            118 Require all granted  
            119 &lt;/Directory&gt;   
            120 &lt;/VirtualHost&gt;  


            121 &lt;VirtualHost 192.168.10.10:6222&gt;  
            122 DocumentRoot &quot;/home/wwwroot/6222&quot;  
            123 ServerName bbs.linuxprobe.com  
            124 &lt;Directory &quot;/home/wwwroot/6222&quot;&gt;  
            125 AllowOverride None  
            126 Require all granted  
            127 &lt;/Directory&gt;  
            128 &lt;/VirtualHost&gt;  


            4.  
            因为我们把网站数据目录存放在/home/wwwroot目录中，因此还是必须要正确设置网站数据目录文件的SELinux安全上下文，使其与网站服务功能相吻合。最后记得用restorecon命令让新配置的SELinux安全上下文立即生效。

            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot  
            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/6111  
            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/6111/*  
            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/6222  
            [root@linuxprobe ~]# semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/6222/*  
            [root@linuxprobe ~]# restorecon -Rv /home/wwwroot/  


            5.  
            因为SELinux服务检测到6111和6222端口原本不属于Apache服务应该需要的资源，但现在却以httpd服务程序的名义监听使用了，所以SELinux会拒绝使用Apache服务使用这两个端口。我们可以**使用semanage命令查询并过滤出所有与HTTP协议相关且SELinux服务允许的端口列表。**

            [root@linuxprobe ~]# semanage port -l | grep http  


            6.  
            SELinux允许的与HTTP协议相关的端口号中默认没有包含6111和6222，因此需要将这两个端口号手动添加进去。该操作会立即生效，而且在系统重启过后依然有效。设置好后再重启httpd服务程序，然后就可以看到网页内容了

            [root@linuxprobe ~]# semanage port -a -t http_port_t -p tcp 6111  
            [root@linuxprobe ~]# semanage port -a -t http_port_t -p tcp 6222  
            [root@linuxprobe ~]# semanage port -l| grep http  
            http_cache_port_t tcp 8080, 8118, 8123, 10001-10010  
            http_cache_port_t udp 3130  
            http_port_t tcp  6222, 6111, 80, 81, 443, 488, 8008, 8009, 8443, 9000  
            pegasus_http_port_t tcp 5988  
            pegasus_https_port_t tcp 5989  
            [root@linuxprobe ~]# systemctl restart httpd  
            [root@linuxprobe ~]# firefox

    - **基本配置样式**

        &lt;VirtualHost IP地址&gt;
        DocumentRoot /对应的目录
        ServerName 对应的域名
        &lt;Directory /虚拟主机的配置目录&gt;
        AllowOverride None  
        Require all granted  
        &lt;/Directory&gt;  
        &lt;/VirtualHost&gt;

- **10.6 Apache的访问口控制**

    Apache可以基于源主机名、源IP地址或源主机上的浏览器特征等信息对网站上的资源进行访问控制。它通过Allow指令允许某个主机访问服务器上的网站资源，通过Deny指令实现禁止访问。在允许或禁止访问网站资源时，还会用到Order指令，这个指令用来定义Allow或Deny指令起作用的顺序，其匹配原则是按照顺序进行匹配，若匹配成功则执行后面的默认指令。比如“Order Allow, Deny”表示先将源主机与允许规则进行匹配，若匹配成功则允许访问请求，反之则拒绝访问请求。

    - **步骤**

        1.  
        现在服务器上的网站数据目录中新建一个子目录 , 并在这个子目录中创建一个包含Successful单词的首页文件  

        [root@linuxprobe ~]# mkdir /var/www/html/server  
        [root@linuxprobe ~]# echo &quot;Successful&quot; &gt; /var/www/html/server/index.html  


        2.  
        打开httpd服务的配置文件，在第129行后面添加下述规则来限制源主机的访问。这段规则的含义是允许使用Firefox浏览器的主机访问服务器上的首页文件，除此之外的所有请求都将被拒绝。使用Firefox浏览器的访问效果如图10-18所示。

        [root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf  
        ………………省略部分输出信息………………
        129 &lt;Directory &quot;/var/www/html/server&quot;&gt;  
        130 SetEnvIf User-Agent &quot;Firefox&quot; ff=1  
        131 Order allow,deny  
        132 Allow from env=ff  
        133 &lt;/Directory&gt;  
        ………………省略部分输出信息………………
        [root@linuxprobe ~]# systemctl restart httpd  
        [root@linuxprobe ~]# firefox

        - 过匹配源主机的IP地址进行访问控制

            除了匹配源主机的浏览器特征之外，还可以通过匹配源主机的IP地址进行访问控制。例如，我们只允许IP地址为192.168.10.20的主机访问网站资源，那么就可以在httpd服务配置文件的第129行后面添加下述规则。这样在重启httpd服务程序后再用本机（即服务器，其IP地址为192.168.10.10）来访问网站的首页面时就会提示访问被拒绝了

            [root@linuxprobe ~]# vim /etc/httpd/conf/httpd.conf  
            ………………省略部分输出信息………………
            129 &lt;Directory &quot;/var/www/html/server&quot;&gt;  
            130 Order allow,deny   
            131 Allow from 192.168.10.20  
            132 &lt;/Directory&gt;  
            ………………省略部分输出信息………………
            [root@linuxprobe ~]# systemctl restart httpd  
            [root@linuxprobe ~]# firefox

- 本章节学习总结

    Linux Apache 命令总结

    配置Yum:
    mkdir 创建挂载目录
    mount 将/dev/cdrom  挂载到 /media/cdrom

    开启httpd服务
    systemctl start httpd 开启
    systemctl restart httpd 重启
    systemctl enable httpd 开启自启

    SELinux:  
    ls -Zd : 查看SE Linux 的命令总结
    getenforce : 查看当前模式
    setenforce : 开关SELinux(临时))

    SELinux - semanage命令
    添加上下文 : semanage fcontext -a -t httpd_sys_content_t /要添加的目录
    *-l -a -m -d fcontext  

    restorecon 命令使其生效

    开启用户主页功能后:
    getsebool -a | grep http 找到阻止用户主页功能的策略
    并使用  
    setsebool -P httpd_enalbe_homedirs=on 使策略httpd_enalbe_homedirs生效

    添加口令:
    htpasswd -c /口令保存目录 用户名
    后修改配置文件  
    /etc/httpd/conf.d/userdir.conf 的第31-15行
    &lt;Directory &quot;/home/*/public_html&quot;&gt;  
    AllowOverride all  
    authuserfile &quot;/刚才的密码保存目录
    authname &quot;提示信息&quot;
    authtype basic  
    require user 要验证的用户名
    &lt;/Directory&gt;  

    会用到的目录:
    /etc/httpd/conf/httpd.conf Apache主配置
    /etc/selinux/config SELinux 配置
    /etc/httpd/conf.d/userdir.conf 开启httpd的个人主页功能
    -#UsreDir disabled 添加#号表示开启个人主页功能 并去掉第二十四行的UserDir public_html 的#号



    Apache的虚拟主机三种形式配置的不同

    基本样式  
    &lt;VirtualHost IP地址&gt;
    DocumentRoot /对应的目录
    ServerName 对应的域名
    &lt;Directory /虚拟主机的配置目录&gt;
    AllowOverride None  
    Require all granted  
    &lt;/Directory&gt;  
    &lt;/VirtualHost&gt;

    - **命令总结**

        所有用到的命令:
        mkdir  
        mount  
        yum  
        vim  
        echo  
        systemctl  
        ls -Zd 查看SELiunx文件上下文
        getenforce  
        setenforce 0|1  
        semanage fcontext  
        restorecon  
        getsebool -a | grep http  
        setsebool -P  
        htpasswd -c

    - </code></pre><ul>
<li><p>概述</p>
<p>  <strong>章节简述：</strong><br>  本章先向读者科普什么是Web服务程序，以及Web服务程序的用处，然后通过对比当前主流的Web服务程序来使读者更好地理解其各自的优势及特点，最后通过对httpd服务程序中“全局配置参数”、“区域配置参数”及“注释信息”的理论讲解和实战部署，确保读者学会Web服务程序的配置方法，并真正掌握在<a href="https://www.linuxprobe.com/" target="_blank" rel="noopener">Linux系统</a>中配置服务的技巧。<br>  <a href="https://www.linuxprobe.com/" target="_blank" rel="noopener">刘遄</a>老师还会在本章讲解SELinux服务的作用、三种工作模式以及策略管理方法，确保读者掌握SELinux域和SELinux安全上下文的配置方法，并依次完成多个基于httpd服务程序实用功能的部署实验，其中包括httpd服务程序的基本部署、个人用户主页功能和口令加密认证方式的实现，以及分别基于IP地址、主机名（域名）、端口号部署虚拟主机网站功能。</p>
</li>
</ul>
<h3 id="第十一章-Vsftpd-暂时跳过"><a href="#第十一章-Vsftpd-暂时跳过" class="headerlink" title="第十一章:Vsftpd(暂时跳过)"></a>第十一章:Vsftpd(暂时跳过)</h3><h3 id="第十二章-Samba与NFS-暂时跳过"><a href="#第十二章-Samba与NFS-暂时跳过" class="headerlink" title="第十二章:Samba与NFS(暂时跳过)"></a>第十二章:Samba与NFS(暂时跳过)</h3><h3 id="第十三章-使用Bind提供域名解析服务"><a href="#第十三章-使用Bind提供域名解析服务" class="headerlink" title="第十三章:使用Bind提供域名解析服务"></a>第十三章:使用Bind提供域名解析服务</h3><p>**章节简述：<br>本章讲解了DNS域名解析服务的原理以及作用，介绍了域名查询功能中正向解析与反向解析的作用，并通过实验的方式演示了如何在DNS主服务器上部署正、反解析工作模式，以便让大家深刻体会到DNS域名查询的便利以及强大。<br>本章还介绍了如何部署DNS从服务器以及DNS缓存服务器来提升用户的域名查询体验，以及如何使用chroot牢笼机制插件来保障bind服务程序的可靠性，并向大家演示如何在主服务器与从服务器之间部署TSIG密钥加密功能，来进一步保障迭代查询中数据的安全性。最后，本章还从实战层面讲解了DNS分离解析技术，让来自不同国家、不同地区的用户都能获得最优的网站访问体验。<br>相信大家在学完本章内容之后，一定会对bind服务程序有更深入的了解和认识，并能深刻地体会到作为互联网基础设施中重要一环的DNS域名解析服务，在互联网中所承担的重要角色和发挥的重要作用。</p>
<ul>
<li><p>目录结构</p>
<p>  **本章目录结构 [<a href="https://www.linuxprobe.com/chapter-13.html#" target="_blank" rel="noopener">收起</a>]</p>
<pre><code>[13.1 DNS域名解析服务](https://www.linuxprobe.com/chapter-13.html#131_DNS)
[13.2 安装Bind服务程序](https://www.linuxprobe.com/chapter-13.html#132_Bind)
[13.2.1 正向解析实验](https://www.linuxprobe.com/chapter-13.html#1321)
[13.2.2 反向解析实验](https://www.linuxprobe.com/chapter-13.html#1322)
[13.3 部署从服务器](https://www.linuxprobe.com/chapter-13.html#133)
[13.4 安全的加密传输](https://www.linuxprobe.com/chapter-13.html#134)
[13.5 部署缓存服务器](https://www.linuxprobe.com/chapter-13.html#135)
[13.6 分离解析技术](https://www.linuxprobe.com/chapter-13.html#136)</code></pre><ul>
<li><p>DNS域名解析服务</p>
<p>  相较于由数字构成的IP地址，域名更容易被理解和记忆，所以我们通常更习惯通过域名的方式来访问网络中的资源。但是，网络中的计算机之间只能基于IP地址来相互识别对方的身份，而且要想在互联网中传输数据，也必须基于外网的IP地址来完成。</p>
<p>  为了降低用户访问网络资源的门槛，DNS（Domain Name System，域名系统）技术应运而生。这是一项用于管理和解析域名与IP地址对应关系的技术，简单来说，就是能够接受用户输入的域名或IP地址，然后自动查找与之匹配（或者说具有映射关系）的IP地址或域名，即将域名解析为IP地址（正向解析），或将IP地址解析为域名（反向解析）。这样一来，我们只需要在浏览器中输入域名就能打开想要访问的网站了。DNS域名解析技术的正向解析也是我们最常使用的一种工作模式</p>
<p>  鉴于互联网中的域名和IP地址对应关系数据库太过庞大，DNS域名解析服务采用了类似目录树的层次结构来记录域名与IP地址之间的对应关系，从而形成了一个分布式的数据库系统</p>
<ul>
<li><p>DNS三种服务器</p>
<ul>
<li><p>主服务器：在特定区域内具有唯一性，负责维护该区域内的域名与IP地址之间的对应关系。</p>
</li>
<li><p>从服务器：从主服务器中获得域名与IP地址的对应关系并进行维护，以防主服务器宕机等情况。</p>
</li>
<li><p>缓存服务器：通过向其他域名解析服务器查询获得域名与IP地址的对应关系，并将经常查询的域名信息保存到服务器本地，以此来提高重复查询时的效率。</p>
</li>
</ul>
</li>
<li><p>递归和迭代查询</p>
<p>  DNS域名解析服务采用分布式的数据结构来存放海量的“区域数据”信息，在执行用户发起的域名查询请求时，具有递归查询和迭代查询两种方式。所谓递归查询，是指DNS服务器在收到用户发起的请求时，必须向用户返回一个准确的查询结果。如果DNS服务器本地没有存储与之对应的信息，则该服务器需要询问其他服务器，并将返回的查询结果提交给用户。而迭代查询则是指，DNS服务器在收到用户发起的请求时，并不直接回复查询结果，而是告诉另一台DNS服务器的地址，用户再向这台DNS服务器提交请求，这样依次反复，直到返回查询结果。</p>
<ul>
<li>查询流程图</li>
</ul>
</li>
</ul>
</li>
<li><p>13.2 安装Bind 服务程序<br>bind服务程序的名称为named</p>
<ul>
<li><p>13.2.1 正向解析实验</p>
<p>  在DNS域名解析服务中，正向解析是指根据域名（主机名）查找到对应的IP地址。也就是说，当用户输入了一个域名后，bind服务程序会自动进行查找，并将匹配到的IP地址返给用户。这也是最常用的DNS工作模式。</p>
<ul>
<li><p><strong>步骤</strong></p>
<ul>
<li><p><strong>1.编辑区域配置文件/etc/named.rfc1912.zones</strong></p>
<p>  vim /etc/named.rfc1912.zones  </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>                在文件末尾添加一下记录:

                zone &quot;linuxprobe.com&quot; IN {  
                type master;  
                file &quot;linuxprobe.com.zone&quot;;  
                allow-update {none;};  
                };

            - **2.编辑数据配置文件 cd /var/named/**

                cd /var/named  

                ls -al named.localhost  

                cp -a named.localhost [linuxprobe.com](http://linuxprobe.com).zone

    - 命令:yum install bind-chroot

    - 三个主要文件

        - 主配置文件（/etc/named.conf）：只有58行，而且在去除注释信息和空行之后，实际有效的参数仅有30行左右，这些参数用来定义bind服务程序的运行。

            - 1.设置:配置主文件,将第11行和第17行地址均设置为 any

                首先需要在/etc目录中找到该服务程序的主配置文件，然后把第11行和第17行的地址均修改为any，分别表示服务器上的所有IP地址均可提供DNS域名解析服务，以及允许所有人对本服务器发送DNS查询请求。这两个地方一定要修改准确。

                - 例子

                    [root@linuxprobe ~]# vim /etc/named.conf  
                     1 //  
                     2 // named.conf  
                     3 //  
                     4 // Provided by Red Hat bind package to configure the ISC BIND named(8) DNS  
                     5 // server as a caching only nameserver (as a localhost DNS resolver only).  
                     6 //  
                     7 // See /usr/share/doc/bind*/sample/ for example named configuration files.  
                     8 //  
                     9   
                     10 options {  
                     11 listen-on port 53 { any; };  
                     12 listen-on-v6 port 53 { ::1; };  
                     13 directory &quot;/var/named&quot;;  
                     14 dump-file &quot;/var/named/data/cache_dump.db&quot;;  
                     15 statistics-file &quot;/var/named/data/named_stats.txt&quot;;  
                     16 memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;;  
                     17 allow-query { any; };  
                     18   
                     19 /*   
                     20 - If you are building an AUTHORITATIVE DNS server, do NOT enable re cursion.

        - 区域配置文件（/etc/named.rfc1912.zones）：用来保存域名和IP地址对应关系的所在位置。类似于图书的目录，对应着每个域和相应IP地址所在的具体位置，当需要查看或修改时，可根据这个位置找到相关文件。

            如前所述，bind服务程序的区域配置文件（/etc/named.rfc1912.zones）用来保存域名和IP地址对应关系的所在位置。在这个文件中，定义了域名与IP地址解析规则保存的文件位置以及服务类型等内容，而没有包含具体的域名、IP地址对应关系等信息。服务类型有三种，分别为hint（根区域）、master（主区域）、slave（辅助区域），其中常用的master和slave指的就是主服务器和从服务器。

            - 正向解析

            - 反向解析

        - 数据配置文件目录（/var/named）：该目录用来保存域名和IP地址真实对应关系的数据配置文件。

    - [LinuxCast.net](http://LinuxCast.net)教程

- **YouTube教程：成功配置Bind**

    视频教程地址：  

    [https://www.youtube.com/watch?v=is-eg2X5ru4](https://www.youtube.com/watch?v=is-eg2X5ru4)

    - **步骤**

        - **虚拟机配置信息**

            系统：全新Redhat 7 未安装任何软件  
            网络适配器：仅主机模式  
            本机IP地址：192.168.44.131

        - **1.安装YUM**

        - **2.YUM安装Bind 和 Bind-Utils**

            1.**查看本机IP**
            命令：ifconfig  
            - 使用ifconfig查询本机IP（没有修改IP）

            2.**查看本机信息**
            命令：hostnamectl  
            -查看主机相关信息  

            3.**安装Bind服务**
            命令：yum install bind bind-utils  
            -安装Bind服务（这里没有安装Chroot）  

            4.**进入主配置文件**
            命令：vim ／etc／named.conf  
            -进入bind（named）主配置文件  

            5.**配置主配置文件**

            在options{  
                listen-on port 53 { 127.0.0.1;这里再添加自己的本机iP地址（也就是刚才ifconfig命令看到的地址；};

            …  

                allow-query { localhost;**any**; };

            };  


            6.**开启named服务**
            命令：systemctl start named  
            命令2: systemctl enable named  
            -开启named服务和设置开机自动启动  
            命令3: systemctl status named  
            -查看是否启动成功：如果显示Active：active（running）表示启动成功正在运行

            7.**配置firewalld防火墙允许53端口**
            命令：firewall-cmd —permanent —add-port=53/tcp  
            命令2：firewall-cmd —permanent —add-port=53/udp  
            命令3：firewall-cmd —reload  
            命令：firewall-cmd —list-all  
            “”“ 配置firewall服务允许53端口，重启，并查看是否配置成功”“”  

            8.**在主配置文件下配置区域文件信息**
            命令：vim ／etc／named.conf  
            -在最下面配置区域zone信息  
            zone “.” IN { …  
            };  

            zone “[example.com](http://example.com)” IN {
            *注：前面没有TAB和空格  
            type master;  
            file “[forward.example.com](http://forward.example.com);
            allow-update { none; };  
            };  

            *备注：例子主机IP 172.25.1.11，方向配置是倒过来的的，当不算最后一个（第四个.11)  

            zone “[1.25.172.in](http://1.25.172.in)-addr.arpa” IN {
            type master;  
            file “[reverse.example.com](http://reverse.example.com)”;
            allow-update { none; };  
            };  


            9.拷贝模板DNS配置文件为刚才设定的文件名（named.conf 的 zone …{  
            type ..  
            file “**这里**”;
            allow-update..  
            };  

            命令：cd ／var/named／  
            命令2: ls  
            命令3: ll  
            命令4: cp named.localhost [forward.example.com](http://forward.example.com)

            10.**编辑**[**forward.example.com**](http://forward.example.com)**文件**
            命令5: vim [forward.example.com](http://forward.example.com)

            编辑[之后的样子：](http://forward.example.com)

            $TTL 1D  
            @ IN SOA [server.example.com](http://server.example.com). [root.example.com](http://root.example.com). (
                                                    0 ; serial  
                                                    1D ; refresh  
                                                    1H ; retry  
                                                    1W ; expire  
                                                    3H ) ; minimum  
            @ IN NS [server.example.com](http://server.example.com).
            @ IN A 192.168.44.131  
            server IN A 192.168.44.131  
            host IN A 192.168.44.131  
            desktop IN A 192.168.44.130  
            client IN A 192.168.44.130  
            *备注：这上面几行使用的是TAB键而不是空格


            11.  
            命令：  
            命令1：cp [forward.example.com](http://forward.example.com) [reverse.example.com](http://reverse.example.com)
            命令2: vim [reverse.example.com](http://reverse.example.com)

            配置后的样子：  

            $TTL 1D  
            @ IN SOA [server.example.com](http://server.example.com). [root.example.com](http://root.example.com). (
                                                    0 ; serial  
                                                    1D ; refresh  
                                                    1H ; retry  
                                                    1W ; expire  
                                                    3H ) ; minimum  
            @ IN NS [server.example.com](http://server.example.com).
            @ IN PTR [example.com](http://example.com).
            server IN A 192.168.44.131  
            host IN A 192.168.44.131  
            desktop IN A 192.168.44.130  
            client IN A 192.168.44.130  
            131 IN PTR [server.example.com](http://server.example.com).
            130 IN PTR [desktop.example.com](http://desktop.example.com).
            *备注这里的是TAB区间而不是空格，同时131和130是本机IP地址最后位数


            12.  
            命令：chown root:named [forward.example.com](http://forward.example.com)
            命令2: chown root:named [example.example.com](http://example.example.com)


            13.**检查是否有书写错误**
            命令：named-checkconf -z /etc/named.conf  
            命令2: named-checkzone **forward** /var/named/[**forward.example.com**](http://forward.example.com)
            命令3: named-checkzone **reverse** /var/named/[**reverse.example.com**](http://reverse.example.com)


            **14.**  
            命令：systemctl restart named  


            15.**Desktop主机**
            使用SSH登录desktop修改Desktop（本机是server）的／etc／resolv.conf文件  

            命令：vim ／etc／resolv.conf  

            修改内容如下：  
            search [example.com](http://example.com)
            nameserver 172.25.1.11  

            命令2:systemctl restart NetworkManager  

            回去确认文件内容是否是刚才修改的文件内容  


            16.Server主机  
            命令：systemctl restart named  
            命令2:ping server  
                如果能Ping同就说明成功  


            17.给Server主机 [forward.example.com](http://forward.example.com)配置文件增添www

            命令：vim /var/named/[forward.example.com](http://forward.example.com)

            编辑之后的样子：  

            $TTL 1D  
            @ IN SOA [server.example.com](http://server.example.com). [root.example.com](http://root.example.com). (
                                                    0 ; serial  
                                                    1D ; refresh  
                                                    1H ; retry  
                                                    1W ; expire  
                                                    3H ) ; minimum  
            @ IN NS [server.example.com](http://server.example.com).
            @ IN A 192.168.44.131  
            server IN A 192.168.44.131  
            host IN A 192.168.44.131  
            www IN A 192.168.44.131  
            desktop IN A 192.168.44.130  
            client IN A 192.168.44.130  
            *备注：这上面几行使用的是TAB键而不是空格


            命令2:systemctl restart named  

            再次 ping www看看，如果不行，检查一遍，并检查／etc/resolv.conf，把nameserver这一行删除  
            只剩  
            search [example.com](http://example.com)

            然后再：命令systemctl restart NetworkManager  

            18.  
            命令 dig [example.com](http://example.com) 查看是否成功</code></pre><h3 id="-12"><a href="#-12" class="headerlink" title=""></a></h3><h3 id="-13"><a href="#-13" class="headerlink" title=""></a></h3><h3 id="-14"><a href="#-14" class="headerlink" title=""></a></h3><h3 id="-15"><a href="#-15" class="headerlink" title=""></a></h3><h3 id="-16"><a href="#-16" class="headerlink" title=""></a></h3><h3 id="-17"><a href="#-17" class="headerlink" title=""></a></h3><h3 id="工具资料"><a href="#工具资料" class="headerlink" title="工具资料"></a>工具资料</h3><ul>
<li><strong>Linux命令大全：</strong><a href="https://www.linuxcool.com/" target="_blank" rel="noopener"><strong>https://www.linuxcool.com/</strong></a></li>
</ul>
<h2 id="LinuxCast-net视频教程"><a href="#LinuxCast-net视频教程" class="headerlink" title="LinuxCast.net视频教程"></a><a href="http://LinuxCast.net" target="_blank" rel="noopener">LinuxCast.net</a>视频教程</h2><h3 id="-18"><a href="#-18" class="headerlink" title=""></a></h3><ul>
<li><p>YUM软件管理</p>
<ul>
<li><p>简介</p>
<p>  Centos和RedHat的RPM软件包管理软件虽然方便，当需要手工解决很多依赖关系。</p>
<p>  <strong>使用YUM就可以解决以下问题：</strong>  </p>
<ol>
<li>自动解决依赖关系  </li>
<li>可以对RPM进行分组，并给予组进行安装操作  </li>
<li>引<strong>入仓库（repo的概念，支持多个仓库</strong></li>
<li>配置简单  </li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code>    什么是YUM仓库？  

    YUM仓库就是存放现在（本机）所有RPM软件包的地方（文件夹），当YUM需要安装一个RPM软件的时候，如果存在依赖关系，会自动在仓库中查找依赖软件并安装  

    · 仓库可以是本地的，也可以通过HTTP／FTP／NFS形式使用集中的 统一的仓库

- 配置

    - 配置文件

        YUM仓库的配置文件保存在：

        ／etc／yum.repos.d／目录下  

        配置步骤  

        把光盘设备中的系统镜像挂载到/media/cdrom目录

        [root@linuxprobe ~]# mkdir -p /media/cdrom  
        [root@linuxprobe ~]# mount /dev/cdrom /media/cdrom  


        在／etc／yum.repos.d/下创建一个配置文件（.repo结尾）  

        其格式如下：  
        [LinuxCast]  
        name = 描述（给自己看）  
        baseurl = 仓库的路径（可以本地也可以网络）  
        enable**d** = 0禁用／1开启 如果没有enabled属性就默认开始
        gpgcheck = 0不校对／1开启校对  

        mirrorlist=动态获取的路径（开启这个回自动修改baseurl的网络获取路径）  



        其他注意事项：  

        - 仓库可以使用file／http／ftp／nfs方式  
        - yum配置文件名可以随便，必须以.repo结尾  
        - 一个配置文件内可以保存多个仓库的配置信息  
        -/etc/yum.repos.d/ 目录下可以存在多个配置文件  

        *Centos默认会有很多配置文件，而Redhat没有，需要自己配制或订阅购买

- 命令

    **常用命令：**  

    yum install software-name 安装指定软件
    yum remove software-name 卸载软件
    yum update software-name 升级软件

    安装完后通过rpm -qi 软件名   命令可以查看软件包  

    **查询命令：**  

    yum search 软件关键词 ： 搜索仓库中的软件  

    yum list ( alll | installed | recent | updates  例如：yum list all)   
    列出全部的 | 安装的 | 最近的 | 更新的 软件  
        - 命令后显示 ： 软件名   版本  属于那个仓库（如果过前面有@就是已经安装的）  

    yum info packagename（软件包名）：查看软件包的信息  
    yum whatprovides filename（文件名）查看这个文件属于那个rpm包的

- 创建一个YUM仓库

    *所有的RPM安装包都在光盘里，但是安装完后只安装了一部分，所以安装完的系统只有1个多g

    RPM软件包都在光盘文件的packages文件夹里

    - 步骤

        1.将光盘中Packages文件夹（RPM软件包文件夹）拷贝到自定的目录中

        命令：cp -rv ／光盘挂在的目录／*  
        ／刚才创建的目录／  


        2.通过rpm命令手工安装createrepo软件  

        命令： rpm -ivh createrepo-0.9.8.5.el6.noarch.rpm  
        如果显示还缺少其他软件包，就把那些软件包的名字加 空格 放在后面  
        （可以使用TAB键补全，要不软件名字不好输）  

        3.使用createrepo命令：  

        createrepo -v ／rpm仓库路径（刚在自己创建rpm目录路径）  

        完成后会在这文件夹下出现一个：  
        repodate文件夹，这是保存索引的文件夹，YUM就是通过读取这些索引文件来获取信息的  

        4.在/etc/yum.repos.d/中添加配置文件  

        []  
        name =   
        baseurl = [file:///绝对路径](file:///%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84)

        enbaled = 1 和 gpgcheck = 0 都可以不创建  

        5.为了提高书的，可以运行  
        yum clean all  
        命令  

        6.使用yum list 查看是否成功  



        *如果有分组信息，这在命令运行的时候用 -g 参数指定分组文件  

        createrepo -g /tmp/*comps.xml /rpm-directory  

        CentOS／RHEL的分组信息保存在光盘repodata／目录下，以文件名comps.xml结尾的ml文件</code></pre><ul>
<li><p>Bind</p>
<ul>
<li><p>简介</p>
<p>  BIND（Berkeley Internet Name Domain）</p>
<p>  -BIND支持Linux ／ UNIX ／ Mac  ／ Windows）</p>
<p>  -BIND服务名称为 named  </p>
<p>  -安装命令：  </p>
<pre><code>yum install -y bind bind-chroot bind-utils  </code></pre><p>  *DNS默认使用UDP ／ TCP 协议 ， 使用端口号为53（domain） ， 953 （rndc）</p>
</li>
<li><p>配置</p>
<ul>
<li><p>配置文件</p>
<p>  BIND配置文件主要保存在两个位置：</p>
<p>  /etc/named.conf -BIND服务主配置文件<br>  /var/named/ -zone文件</p>
<p>  <strong>如果安装了bind-chroot ， BIND会被封装到一个伪根目录内，配置文件的位置变为：</strong></p>
<p>  ／var/named/chroot/etc/named.conf<br>  -BIND服务主配置文件</p>
<p>  /var/named/chroot/var/named/<br>  -zone文件</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>*chroot 是通过将相关文件封装在一个伪根目录内，以达到安全防护的目的，一代该程序被攻破，将只能访问伪根目录的内容，而不是真实的目录

- 1.拷贝默认模板配置文件

    BIND在BIND文档文件夹内（**/usr/share/doc/bind-9.x.x**），BIND为我们提供了配置模板，我们可以直拷贝过来

    cp -rv /usr/share/doc/bind-9.x.x/sample/**etc**/*    /var/named/chroot/**etc**


    cp -rv /usr/share/doc/bind-9.x.x/sample/**var**/*    /var/named/chroot/**var**


    实例**中的主配置文件内容较多，实验环境下我么可以删除不需要的内容，最小化配置：**

    **options{  
        listion-on port 53 {127.0.0.1;}:  
        directory “/var/named”;  
    };**

- 2.修改主配置文件

    cd /var/named/chroot/etc/  

    vim named.conf  

    删除掉  

    删除掉包括logging和后面的所有内容（因为大多都用不到）  

    logging  
    {  

    然后删除options里的  

    ／*  
        Access restrictions  
        直到  
    };  



    **最后保存的内容样子：**  

    options  
    {  
            // Put files that named is allowed to write in the data/ directory:  
            directory &quot;/var/named&quot;; // &quot;Working&quot; directory（指定工作目录）

            listen-on port 53 { 127.0.0.1; };//指定ipv4监听地址
            listen-on-v6 port 53 { ::1; };//指定ipv6监听地址

    };  


    都是默认53端口，都是默认监听本地环回

- 3.域的主服务器步骤

    1.在bind的主配置文件中添加该域的定义
    3. 在／var／named／chroot／var/name中 创建该域的zone文件  
    5.编辑zone文件，添加需要的信息  
    7.启动bind服务或使bind刷新配置  
    9.使用host或dig命令检测域信息是否正常

    - 3-1.在bind的主配置文件中添加该域的定义

        配置文件位置：/var/named/chroot/etc/named.conf  

        在主配置文件中添加一行域的zone定义：  

        zone “”[linuxcast.net](http://linuxcast.net)”{
            type master;//类型主域名  
            file “linuxcast.net.zone”;//配置文件的文件名  
        };  

        每一个服务器负责的域都需要又一个zone定义

    - 3-2.创建zone配置文件

        文件位置：  

        /var/named/chroot/var/named/[linuxcast.net](http://linuxcast.net).zone

        zone文件内容：  

        zone文件内容比较复杂，手工输入及其容易输入错误，所以一般使用默认的named.localhost配置文件作为模板  

        cp named.localhost [linuxcast.net](http://linuxcast.net).zone

        拷贝后编辑文件：  

        添加一个资源记录（RP）：  

        www     IN A     192.168.1.1  

        www 主机名  
        IN A IN = Internet ，A代表ipv4地址  
        192.168.1.111 是IP地址  

        ls -l 看看这些文件是否都有读取权限  

        关闭enforce（避免影响实验）  


        **完整的配置演示：**  


        $TTL 1D  
        @ IN SOA @ rname.invalid. (  
                                                0 ; serial  
                                                1D ; refresh  
                                                1H ; retry  
                                                1W ; expire  
                                                3H ) ; minimum  
                NS @  
                A 127.0.0.1  
                AAAA ::1  
        www IN A 192.168.1.111  
        mail IN A 192.168.1.222  
                IN MX 10 mail.linxucast.net.

    - 3-3.启动bind服务或刷新配置

        service named start  
        service named reload

    - 3-4.将本机的dns配置指向本机

        /etc/resolv.conf  
        nameserver 127.0.0.1  

        如果有其他电脑，指向本机ip就可以，因为当前主机已经是一个DNS服务器了

    - 3-5.使用命令host或dig验证dns配置

        host [www.linuxcast.net](http://www.linuxcast.net)
        dig www.linuxcast.net</code></pre><h2 id="碎片化知识"><a href="#碎片化知识" class="headerlink" title="碎片化知识"></a>碎片化知识</h2><h3 id="Mac-SSH连接虚拟机里的Ubuntu"><a href="#Mac-SSH连接虚拟机里的Ubuntu" class="headerlink" title="Mac SSH连接虚拟机里的Ubuntu"></a>Mac SSH连接虚拟机里的Ubuntu</h3><ul>
<li><p>方法步骤</p>
<p>  1.首先要让虚拟机使用”桥接网络”<br>  2.命令 ps -e | grep ssh ,如有sshd 和 ssh-agent表明已启用SSH服务<br>  3.没有就安装SSH客户端和服务端:<br>  命令:   </p>
<pre><code>sudo apt-get install openssh-client  

sudo apt-get install openssh-server  </code></pre><p>  4.启用SSH  </p>
<p>  sudo /etc/init.d/ssh start  </p>
<p>  *默认端口22,如需修改端口号:<br>   sudo gedit /etc/ssh/sshd_config<br>  后<br>  sudo /etc/init.d/ssh restart  </p>
<p>  5.Mac登录使用命令:<br>  ssh 用户名@主机IP</p>
</li>
</ul>
<h3 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h3><ul>
<li><p>FHS（Filesystem Hierarchy Standard）</p>
<p>  FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数 Linux 版本采用这种文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。 FHS 定义了两层规范，第一层是， / 下面的各个目录应该要放什么文件数据，例如 /etc应该要放置设置文件，/bin 与 /sbin 则应该要放置可执行文件等等。</p>
<ul>
<li><p>第一层</p>
<ul>
<li><p>etc</p>
<ul>
<li></li>
</ul>
</li>
<li><p>bin</p>
</li>
<li><p>sbin</p>
</li>
</ul>
</li>
<li><p>第二层</p>
<ul>
<li><p>usr</p>
<ul>
<li><p>bin：可执行二进制文件的目录，如常用的命令：ls，mv，cat等</p>
</li>
<li><p>share：共享数据</p>
</li>
</ul>
</li>
<li><p>var：放置系统中经常变化的文件</p>
<p>  /var：放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。建议单独分区，设置较大的磁盘空间</p>
<ul>
<li>log：系统登录文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>参考网页</p>
<p>  <a href="https://www.cnblogs.com/sytfyf/p/6364691.html" target="_blank" rel="noopener">https://www.cnblogs.com/sytfyf/p/6364691.html</a></p>
</li>
</ul>
<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a><strong>技巧</strong></h3><ul>
<li><p><strong>在Shell里查看图片</strong></p>
<ul>
<li><p>方法</p>
<ul>
<li><p>方法1: 使用命令：python -m SimpleHTTPServer 然后 打开浏览器输入主机iP地址：8000/图片名.jpg</p>
<ul>
<li><p>网址</p>
<p>  <a href="https://www.v2ex.com/t/256629" target="_blank" rel="noopener">https://www.v2ex.com/t/256629</a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="等待探索"><a href="#等待探索" class="headerlink" title="等待探索"></a><strong>等待探索</strong></h3><ul>
<li>Linux ELF文件和使用readelf读取ELF文件</li>
</ul>
<h2 id="遇到的问题与解决办法"><a href="#遇到的问题与解决办法" class="headerlink" title="遇到的问题与解决办法"></a><strong>遇到的问题与解决办法</strong></h2><h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><ul>
<li><p>Mac VirtualBox </p>
<ul>
<li><p>安装</p>
<ul>
<li><p>安装yum提示 no medium found on /dev/sr0</p>
<ul>
<li><p>解决办法</p>
<ul>
<li>在VirtualBox的虚拟主机设置中 -&gt; 存储 -&gt; IDE控制器 加载虚拟光盘 -&gt; 并在启动顺序设置中将光盘放到最后一位,否则会不仅进入系统而是开始进入安装界面</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>网络</p>
<ul>
<li><p>仅主机模式</p>
<ul>
<li><p>教程</p>
<p>  <a href="https://blog.csdn.net/dkfajsldfsdfsd/article/details/79441874" target="_blank" rel="noopener">https://blog.csdn.net/dkfajsldfsdfsd/article/details/79441874</a></p>
</li>
<li><p>不能联网的解决办法</p>
<ol>
<li><p>在VirtualBox的总管理设置的主机网络管理器中创建两个网卡并启用</p>
</li>
<li><p>在Linux内部的右上角选择对应的网卡启动</p>
</li>
</ol>
<ul>
<li>解决办法2:设置桥接模式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul>
<li><ul>
<li><p>Screen</p>
<ul>
<li><p>问题:screen另一个主机进入后找不到会话内容</p>
<ul>
<li>解决办法:看看是否另一个主机是在root情况下开启的会话,如果是则需要当前主机也切换到root模式下才可以查看会话</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><ul>
<li><p>Vim复制时空格缩紧混乱的解决办法</p>
<ul>
<li><p>复制器进入命令模式输入：set paste</p>
</li>
<li><p>复制完输入：set nopaste（关闭paste）</p>
</li>
</ul>
</li>
<li><p>Vim中E212:无法打开并写入文件的解决办法</p>
<p>  参考文章<br>  <a href="https://blog.csdn.net/qq_35038153/article/details/78174109" target="_blank" rel="noopener">https://blog.csdn.net/qq_35038153/article/details/78174109</a></p>
<p>  在编写配置文件时，常常忘记切换到root用户，导致文件编辑完毕，敲入:wq 退出保存时，出现 E212：无法打开并写入文件 的错误提示。这是由于在该目录下当前用户没有写权限导致。<br>  解决办法如下：<br>  【1】 将文件保存到用户目录下，再改变所有者，然后移动到配置目录下，步骤如下：</p>
<pre><code>1） 保存退出时用 :wq ! ~/tmp/file.conf
2）su切换到root用户，将file.conf改变属主， chown root file.conf
3）移动配置文件到目标目录，mv file.conf  [pathname]</code></pre><p>  【2】 第二种解决办法相对比较简便</p>
<pre><code>保存文件时用  : w ! sudo tee %</code></pre><p>  tee 用于读取输入文件，同时保存<br>   %表示当前编辑文件<br>  （不过这种方法有个要求就是当前编辑用户必须在 sudoers这个文件中，这也是执行sudo命令的要求）</p>
<ul>
<li>保存的时候输入命令：w ！sudo tee %</li>
</ul>
</li>
</ul>
<h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><ul>
<li><p>在安装 bind-chroot时显示:镜像错误</p>
<ul>
<li><p>解决办法</p>
<ul>
<li><p>使用命令umount -f /dev/sr0 强制解除挂载后,再次mount /dev/cdrom /media/cdrom  就可以了</p>
<ul>
<li>另外,在yum history 查看历史后发现再次运行yum install bind-chroot时显示遇到yum lock,只要ps -ef | grep 这个pid ,找到后确认使用 kill 这个 pid 就可以了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h2><h3 id="安装Pycharm如此简单"><a href="#安装Pycharm如此简单" class="headerlink" title="安装Pycharm如此简单"></a>安装Pycharm如此简单</h3><ul>
<li>解压-进入解压后的文件的bin文件夹-进入命令行-输入：sh ./pycharm.sh 就行了！</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/10/Linux%E5%AD%A6%E4%B9%A0/" data-id="ckchm9w3q0005wwca0jfp3zih" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/07/11/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/test/" style="font-size: 10px;">test</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/11/test-test/">test test</a>
          </li>
        
          <li>
            <a href="/2020/07/11/My-New-Blog-Article/">My New Blog Article</a>
          </li>
        
          <li>
            <a href="/2020/07/11/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/07/10/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>